<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>reentrantlock | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="深入理解ReentrantLock在Java中通常实现锁有两种方式，一种是synchronized关键字，另一种是Lock。二者其实并没有什么必然联系，但是各有各的特点，在使用中可以进行取舍的使用。首先我们先对比下两者。">
<meta property="og:type" content="article">
<meta property="og:title" content="reentrantlock">
<meta property="og:url" content="http://yoursite.com/2019/04/07/reentrantlock/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="深入理解ReentrantLock在Java中通常实现锁有两种方式，一种是synchronized关键字，另一种是Lock。二者其实并没有什么必然联系，但是各有各的特点，在使用中可以进行取舍的使用。首先我们先对比下两者。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2177145-70687c853ec59e43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2177145-c918a16e5a7116e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-07-18T13:02:49.051Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="reentrantlock">
<meta name="twitter:description" content="深入理解ReentrantLock在Java中通常实现锁有两种方式，一种是synchronized关键字，另一种是Lock。二者其实并没有什么必然联系，但是各有各的特点，在使用中可以进行取舍的使用。首先我们先对比下两者。">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2177145-70687c853ec59e43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-reentrantlock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/07/reentrantlock/" class="article-date">
  <time datetime="2019-04-07T03:37:39.000Z" itemprop="datePublished">2019-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      reentrantlock
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="深入理解ReentrantLock"><a href="#深入理解ReentrantLock" class="headerlink" title="深入理解ReentrantLock"></a>深入理解ReentrantLock</h3><p>在Java中通常实现锁有两种方式，一种是synchronized关键字，另一种是Lock。二者其实并没有什么必然联系，但是各有各的特点，在使用中可以进行取舍的使用。首先我们先对比下两者。</p>
<a id="more"></a>
<h5 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h5><p>首先最大的不同：synchronized是基于JVM层面实现的，而Lock是基于JDK层面实现的。曾经反复的找过synchronized的实现，可惜最终无果。但Lock却是基于JDK实现的，我们可以通过阅读JDK的源码来理解Lock的实现。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用:"></a>使用:</h5><p>对于使用者的直观体验上Lock是比较复杂的，需要lock和realse，如果忘记释放锁就会产生死锁的问题，所以，通常需要在finally中进行锁的释放。但是synchronized的使用十分简单，只需要对自己的方法或者关注的同步对象或类使用synchronized关键字即可。但是对于锁的粒度控制比较粗，同时对于实现一些锁的状态的转移比较困难。例如：</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>tips    synchronized    Lock<br>锁获取超时    不支持    支持<br>获取锁响应中断    不支持    支持</p>
<h5 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h5><p>在JDK1.5之后synchronized引入了偏向锁，轻量级锁和重量级锁，从而大大的提高了synchronized的性能，同时对于synchronized的优化也在继续进行。期待有一天能更简单的使用java的锁。</p>
<p>在以前不了解Lock的时候，感觉Lock使用实在是太复杂，但是了解了它的实现之后就被深深吸引了。</p>
<p>Lock的实现主要有ReentrantLock、ReadLock和WriteLock，后两者接触的不多，所以简单分析一下ReentrantLock的实现和运行机制。</p>
<p>ReentrantLock类在java.util.concurrent.locks包中，它的上一级的包java.util.concurrent主要是常用的并发控制类.<br><img src="https://upload-images.jianshu.io/upload_images/2177145-70687c853ec59e43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>下面是ReentrantLock的UML图，从图中可以看出，ReentrantLock实现Lock接口，在ReentrantLock中引用了AbstractQueuedSynchronizer的子类，所有的同步操作都是依靠AbstractQueuedSynchronizer（队列同步器）实现。<br><img src="https://upload-images.jianshu.io/upload_images/2177145-c918a16e5a7116e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image1"><br>研究一个类，需要从一个类的静态域，静态类，静态方法和成员变量开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 7373984872572414699L;</span><br><span class="line">   /** Synchronizer providing all implementation mechanics */</span><br><span class="line">   private final Sync sync;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Base of synchronization control for this lock. Subclassed</span><br><span class="line">    * into fair and nonfair versions below. Uses AQS state to</span><br><span class="line">    * represent the number of holds on the lock.</span><br><span class="line">    */</span><br><span class="line">   abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">       private static final long serialVersionUID = -5179523762034025860L;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing</span><br><span class="line">        * is to allow fast path for nonfair version.</span><br><span class="line">        */</span><br><span class="line">       abstract void lock();</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Performs non-fair tryLock.  tryAcquire is</span><br><span class="line">        * implemented in subclasses, but both need nonfair</span><br><span class="line">        * try for trylock method.</span><br><span class="line">        */</span><br><span class="line">       final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">           final Thread current = Thread.currentThread();</span><br><span class="line">           int c = getState();</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">               if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               int nextc = c + acquires;</span><br><span class="line">               if (nextc &lt; 0) // overflow</span><br><span class="line">                   throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">           int c = getState() - releases;</span><br><span class="line">           if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               throw new IllegalMonitorStateException();</span><br><span class="line">           boolean free = false;</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">               free = true;</span><br><span class="line">               setExclusiveOwnerThread(null);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           return free;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       protected final boolean isHeldExclusively() &#123;</span><br><span class="line">           // While we must in general read state before owner,</span><br><span class="line">           // we don&apos;t need to do so to check if current thread is owner</span><br><span class="line">           return getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final ConditionObject newCondition() &#123;</span><br><span class="line">           return new ConditionObject();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Methods relayed from outer class</span><br><span class="line"></span><br><span class="line">       final Thread getOwner() &#123;</span><br><span class="line">           return getState() == 0 ? null : getExclusiveOwnerThread();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final int getHoldCount() &#123;</span><br><span class="line">           return isHeldExclusively() ? getState() : 0;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final boolean isLocked() &#123;</span><br><span class="line">           return getState() != 0;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Reconstitutes this lock instance from a stream.</span><br><span class="line">        * @param s the stream</span><br><span class="line">        */</span><br><span class="line">       private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">           throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">           s.defaultReadObject();</span><br><span class="line">           setState(0); // reset to unlocked state</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出来首先ReentrantLock是可序列化的，其次是ReentrantLock里有一个对AbstractQueuedSynchronizer的引用。</p>
<p>看完了成员变量和静态域，我们需要了解下构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Creates an instance of &#123;@code ReentrantLock&#125;.</span><br><span class="line">     * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line">     */</span><br><span class="line">    public ReentrantLock() &#123;</span><br><span class="line">        sync = new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line">     * given fairness policy.</span><br><span class="line">     *</span><br><span class="line">     * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line">     */</span><br><span class="line">    public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，ReentrantLock支持两种锁模式，公平锁和非公平锁。默认的实现是非公平的。公平和非公平锁的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Sync object for non-fair locks</span><br><span class="line">     */</span><br><span class="line">    static final class NonfairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">         * acquire on failure.</span><br><span class="line">         */</span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            if (compareAndSetState(0, 1))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sync object for fair locks</span><br><span class="line">     */</span><br><span class="line">    static final class FairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Fair version of tryAcquire.  Don&apos;t grant access unless</span><br><span class="line">         * recursive call or no waiters or is first.</span><br><span class="line">         */</span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>AbstractQueuedSynchronizer 是一个抽象类，所以在使用这个同步器的时候，需要通过自己实现预期的逻辑，Sync、FairSync和NonfairSync都是ReentrantLock为了实现自己的需求而实现的内部类，之所以做成内部类，我认为是只在ReentrantLock使用上述几个类，在外部没有使用到。<br>我们着重关注默认的非公平锁的实现：<br>在ReentrantLock调用lock()的时候，调用的是下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Acquires the lock.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;Acquires the lock if it is not held by another thread and returns</span><br><span class="line">     * immediately, setting the lock hold count to one.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;If the current thread already holds the lock then the hold</span><br><span class="line">     * count is incremented by one and the method returns immediately.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;If the lock is held by another thread then the</span><br><span class="line">     * current thread becomes disabled for thread scheduling</span><br><span class="line">     * purposes and lies dormant until the lock has been acquired,</span><br><span class="line">     * at which time the lock hold count is set to one.</span><br><span class="line">     */</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>sync的实现是NonfairSync，所以调用的是NonfairSync的lock方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Sync object for non-fair locks</span><br><span class="line">     * tips：调用Lock的时候，尝试获取锁，这里采用的CAS去尝试获取锁，如果获取锁成功</span><br><span class="line">     *       那么，当前线程获取到锁，如果失败，调用acquire处理。</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    static final class NonfairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">         * acquire on failure.</span><br><span class="line">         */</span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            </span><br><span class="line">            if (compareAndSetState(0, 1))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来看看compareAndSetState方法是怎么进行锁的获取操作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Atomically sets synchronization state to the given updated</span><br><span class="line">     * value if the current state value equals the expected value.</span><br><span class="line">     * This operation has memory semantics of a &lt;tt&gt;volatile&lt;/tt&gt; read</span><br><span class="line">     * and write.</span><br><span class="line">     *</span><br><span class="line">     * @param expect the expected value</span><br><span class="line">     * @param update the new value</span><br><span class="line">     * @return true if successful. False return indicates that the actual</span><br><span class="line">     *         value was not equal to the expected value.</span><br><span class="line">     *         </span><br><span class="line">     * tips： 1.compareAndSetState的实现主要是通过Unsafe类实现的。</span><br><span class="line">     *       2.之所以命名为Unsafe，是因为这个类对于JVM来说是不安全的，我们平时也是使用不了这个类的。</span><br><span class="line">     *       3.Unsafe类内封装了一些可以直接操作指定内存位置的接口，是不是感觉和C有点像了？</span><br><span class="line">     *       4.Unsafe类封装了CAS操作，来达到乐观的锁的争抢的效果</span><br><span class="line">     */</span><br><span class="line">    protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">        // See below for intrinsics setup to support this</span><br><span class="line">        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要的说明都在方法的注释中，接下来简单的看一下 compareAndSwapInt的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently</span><br><span class="line">     * holding &lt;tt&gt;expected&lt;/tt&gt;.</span><br><span class="line">     * @return &lt;tt&gt;true&lt;/tt&gt; if successful</span><br><span class="line">     */</span><br><span class="line">    public final native boolean compareAndSwapInt(Object o, long offset,</span><br><span class="line">                                                  int expected,</span><br><span class="line">                                                  int x);</span><br></pre></td></tr></table></figure>

<p>一个native方法，沮丧…..但是从注释看意思是，以CAS的方式将制定字段设置为指定的值。同时我们也明白了这个方法可能是用java实现不了，只能依赖JVm底层的C代码实现。下面看看操作的stateOffset：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    private static final long stateOffset;</span><br><span class="line">    private static final long headOffset;</span><br><span class="line">    private static final long tailOffset;</span><br><span class="line">    private static final long waitStatusOffset;</span><br><span class="line">    private static final long nextOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //这个方法很有意思，主要的意思是获取AbstractQueuedSynchronizer的state成员的偏移量</span><br><span class="line">            //通过这个偏移量来更新state成员，另外state是volatile的来保证可见性。</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">            headOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;));</span><br><span class="line">            tailOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));</span><br><span class="line">            waitStatusOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(&quot;waitStatus&quot;));</span><br><span class="line">            nextOffset = unsafe.objectFieldOffset</span><br><span class="line">                (Node.class.getDeclaredField(&quot;next&quot;));</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>stateOffset 是AbstractQueuedSynchronizer内部定义的一个状态量，AbstractQueuedSynchronizer是线程的竞态条件，所以只要某一个线程CAS改变状态成功，同时在没有释放的情况下，其他线程必然失败（对于Unsafe类还不是很熟悉，后面还需要系统的学习）。<br>对于竞争成功的线程会调用 setExclusiveOwnerThread方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * The current owner of exclusive mode synchronization.</span><br><span class="line">     */</span><br><span class="line">    private transient Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets the thread that currently owns exclusive access. A</span><br><span class="line">     * &lt;tt&gt;null&lt;/tt&gt; argument indicates that no thread owns access.</span><br><span class="line">     * This method does not otherwise impose any synchronization or</span><br><span class="line">     * &lt;tt&gt;volatile&lt;/tt&gt; field accesses.</span><br><span class="line">     */</span><br><span class="line">    protected final void setExclusiveOwnerThread(Thread t) &#123;</span><br><span class="line">        exclusiveOwnerThread = t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个实现是比较简单的，只是获取当前线程的引用，令AbstractOwnableSynchronizer中的exclusiveOwnerThread引用到当前线程。竞争失败的线程，会调用acquire方法，这个方法也是ReentrantLock设计的精华之处：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span><br><span class="line">     * by invoking at least once &#123;@link #tryAcquire&#125;,</span><br><span class="line">     * returning on success.  Otherwise the thread is queued, possibly</span><br><span class="line">     * repeatedly blocking and unblocking, invoking &#123;@link</span><br><span class="line">     * #tryAcquire&#125; until success.  This method can be used</span><br><span class="line">     * to implement method &#123;@link Lock#lock&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param arg the acquire argument.  This value is conveyed to</span><br><span class="line">     *        &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and</span><br><span class="line">     *        can represent anything you like.</span><br><span class="line">     * tips:此处主要是处理没有获取到锁的线程</span><br><span class="line">     *   tryAcquire：重新进行一次锁获取和进行锁重入的处理。</span><br><span class="line">     *      addWaiter：将线程添加到等待队列中。</span><br><span class="line">     *   acquireQueued：自旋获取锁。      </span><br><span class="line">     *      selfInterrupt：中断线程。</span><br><span class="line">     *      三个条件的关系为and,如果 acquireQueued返回true，那么线程被中断selfInterrupt会中断线程</span><br><span class="line">     */</span><br><span class="line">    public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>AbstractQueuedSynchronizer为抽象方法，调用tryAcquire时，调用的为NonfairSync的tryAcquire。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            return nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">       /**</span><br><span class="line">         * Performs non-fair tryLock.  tryAcquire is</span><br><span class="line">         * implemented in subclasses, but both need nonfair</span><br><span class="line">         * try for trylock method.</span><br><span class="line">         */</span><br><span class="line">        final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0) // overflow</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">````        </span><br><span class="line">nonfairTryAcquire方法主要是做重入锁的实现，synchronized本身支持锁的重入，而ReentrantLock则是通过此处实现。在锁状态为0时，重新尝试获取锁。如果已经被占用，那么做一次是否当前线程为占用锁的线程的判断，如果是一样的那么进行计数，当然在锁的relase过程中会进行递减，保证锁的正常释放。</span><br><span class="line">如果没有重新获取到锁或者锁的占用线程和当前线程是一个线程，方法返回false。那么把线程添加到等待队列中，调用addWaiter：</span><br></pre></td></tr></table></figure>

<p>   /**<br>     * Creates and enqueues node for current thread and given mode.<br>     *<br>     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared<br>     * @return the new node<br>     <em>/<br>    private Node addWaiter(Node mode) {<br>        Node node = new Node(Thread.currentThread(), mode);<br>        // Try the fast path of enq; backup to full enq on failure<br>        Node pred = tail;<br>        if (pred != null) {<br>            node.prev = pred;<br>            if (compareAndSetTail(pred, node)) {<br>                pred.next = node;<br>                return node;<br>            }<br>        }<br>        enq(node);<br>        return node;<br>    }<br>/*</em><br>     * Inserts node into queue, initializing if necessary. See picture above.<br>     * @param node the node to insert<br>     * @return node’s predecessor<br>     */<br>    private Node enq(final Node node) {<br>        for (;;) {<br>            Node t = tail;<br>            if (t == null) { // Must initialize<br>                if (compareAndSetHead(new Node()))<br>                    tail = head;<br>            } else {<br>                node.prev = t;<br>                if (compareAndSetTail(t, node)) {<br>                    t.next = node;<br>                    return t;<br>                }<br>            }<br>        }<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里主要是用当前线程构建一个Node的等待队列双向链表，这里addWaiter中和enq中的部分逻辑是重复的，个人感觉可能是如果能一次成功就避免了enq中的死循环。因为tail节点是volatile的同时node也是不会发生竞争的所以node.prev = pred;是安全的。但是tail的next是不断竞争的，所以利用compareAndSetTail保证操作的串行化。接下来调用acquireQueued方法：</span><br></pre></td></tr></table></figure>

<p>/**<br>     * Acquires in exclusive uninterruptible mode for thread already in<br>     * queue. Used by condition wait methods as well as acquire.<br>     *<br>     * @param node the node<br>     * @param arg the acquire argument<br>     * @return {@code true} if interrupted while waiting<br>     */<br>    final boolean acquireQueued(final Node node, int arg) {<br>        boolean failed = true;<br>        try {<br>            boolean interrupted = false;<br>            for (;;) {<br>                final Node p = node.predecessor();<br>                if (p == head &amp;&amp; tryAcquire(arg)) {<br>                    setHead(node);<br>                    p.next = null; // help GC<br>                    failed = false;<br>                    return interrupted;<br>                }<br>                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = true;<br>            }<br>        } finally {<br>            if (failed)<br>                cancelAcquire(node);<br>        }<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此处是做Node节点线程的自旋过程，自旋过程主要检查当前节点是不是head节点的next节点，如果是，则尝试获取锁，如果获取成功，那么释放当前节点，同时返回。至此一个非公平锁的锁获取过程结束。</span><br><span class="line">如果这里一直不断的循环检查，其实是很耗费性能的，JDK的实现肯定不会这么“弱智”，所以有了shouldParkAfterFailedAcquire和parkAndCheckInterrupt，这两个方法就实现了线程的等待从而避免无限的轮询：</span><br></pre></td></tr></table></figure>

<p> /<em>*<br>     * Checks and updates status for a node that failed to acquire.<br>     * Returns true if thread should block. This is the main signal<br>     * control in all acquire loops.  Requires that pred == node.prev<br>     *<br>     * @param pred node’s predecessor holding status<br>     * @param node the node<br>     * @return {@code true} if thread should block<br>     */<br>    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {<br>        int ws = pred.waitStatus;<br>        if (ws == Node.SIGNAL)<br>            /</em><br>             * This node has already set status asking a release<br>             * to signal it, so it can safely park.<br>             <em>/<br>            return true;<br>        if (ws &gt; 0) {<br>            /</em><br>             * Predecessor was cancelled. Skip over predecessors and<br>             * indicate retry.<br>             <em>/<br>            do {<br>                node.prev = pred = pred.prev;<br>            } while (pred.waitStatus &gt; 0);<br>            pred.next = node;<br>        } else {<br>            /</em><br>             * waitStatus must be 0 or PROPAGATE.  Indicate that we<br>             * need a signal, but don’t park yet.  Caller will need to<br>             * retry to make sure it cannot acquire before parking.<br>             */<br>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        }<br>        return false;<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先，检查一下当前Node的前置节点pred是否是SIGNAL，如果是SIGNAL，那么证明前置Node的线程已经Park了，如果waitStatus&gt;0,那么当前节点已经Concel或者中断。那么不断调整当前节点的前置节点，将已经Concel的和已经中断的线程移除队列。如果waitStatus&lt;0,那么设置waitStatus为SIGNAL，因为调用shouldParkAfterFailedAcquire的方法为死循环调用，所以终将返回true。接下来看parkAndCheckInterrupt方法，当shouldParkAfterFailedAcquire返回True的时候执行parkAndCheckInterrupt方法：</span><br></pre></td></tr></table></figure>

<p>private final boolean parkAndCheckInterrupt() {<br>        LockSupport.park(this);<br>        return Thread.interrupted();<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此方法比较简单，其实就是使当前的线程park，即暂停了线程的轮询。当Unlock时会做后续节点的Unpark唤醒线程继续争抢锁。</span><br><span class="line">接下来看一下锁的释放过程，锁释放主要是通过unlock方法实现：</span><br></pre></td></tr></table></figure>

<p> /**<br>     * Attempts to release this lock.<br>     *<br>     * </p><p>If the current thread is the holder of this lock then the hold<br>     * count is decremented.  If the hold count is now zero then the lock<br>     * is released.  If the current thread is not the holder of this<br>     * lock then {@link IllegalMonitorStateException} is thrown.<br>     *<br>     * @throws IllegalMonitorStateException if the current thread does not<br>     *         hold this lock<br>     */<br>    public void unlock() {<br>        sync.release(1);<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要是调用AbstractQueuedSynchronizer同步器的release方法：</span><br></pre></td></tr></table></figure>

<pre><code>/**
 * Releases in exclusive mode.  Implemented by unblocking one or
 * more threads if {@link #tryRelease} returns true.
 * This method can be used to implement method {@link Lock#unlock}.
 *
 * @param arg the release argument.  This value is conveyed to
 *        {@link #tryRelease} but is otherwise uninterpreted and
 *        can represent anything you like.
 * @return the value returned from {@link #tryRelease}
 */
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tryRelease方法为ReentrantLock中的Sync的tryRelease方法：</span><br></pre></td></tr></table></figure>

<pre><code>protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tryRelease方法主要是做了一个释放锁的过程，将同步状态state -1，直到减到0为止，这主要是兼容重入锁设计的，同时setExclusiveOwnerThread(null)清除当前占用的线程。这些head节点后的线程和新进的线程就可以开始争抢。这里需要注意的是对于同步队列中的线程来说在setState(c)，且c为0的时候，同步队列中的线程是没有竞争锁的，因为线程被park了还没有唤醒。但是此时对于新进入的线程是有机会获取到锁的。</span><br><span class="line">下面代码是进行线程的唤醒：</span><br></pre></td></tr></table></figure>

<p> Node h = head;<br>            if (h != null &amp;&amp; h.waitStatus != 0)<br>                unparkSuccessor(h);<br>            return true;</p>
<pre><code>因为在setState(c)释放了锁之后，是没有线程竞争的，所以head是当前的head节点，先检查当前的Node是否合法，如果合法则unpark it。开始锁的获取。就回到了上面的for循环执行获取锁逻辑：
![image3](https://upload-images.jianshu.io/upload_images/2177145-643cf2c4b0958ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
至此锁的释放就结束了，可以看到ReentrantLock是一个不断的循环的状态模型，里面有很多东西值得我们学习和思考。

ReentrantLock具有公平和非公平两种模式，也各有优缺点：
公平锁是严格的以FIFO的方式进行锁的竞争，但是非公平锁是无序的锁竞争，刚释放锁的线程很大程度上能比较快的获取到锁，队列中的线程只能等待，所以非公平锁可能会有“饥饿”的问题。但是重复的锁获取能减小线程之间的切换，而公平锁则是严格的线程切换，这样对操作系统的影响是比较大的，所以非公平锁的吞吐量是大于公平锁的，这也是为什么JDK将非公平锁作为默认的实现。

流程总结：
#### 非公平锁：
线程去获取锁时，只检查cms状态，而不管有无在排队的线程，所以新来的线程可以和已经排队的线程进行争抢，而且抢赢得概率很大。因为排队中的线程如果被park了，锁释放后会有个unpark的过程然后再去获取锁。如果这个过程中新来的线程直接通过cms获取到了锁，则队列中的就只能等待。
若成功，则获取锁，并设置状态c,将获取锁的线程设置为当前线程。
若不成功，则再试图获取一次，再不成功，则将当前线程插入到一个双向链表的头部节点中。然后返回这个节点并在自旋中判断这个节点的前置节点是否为头结点，如果是，则循环地尝试获取锁。这个过程中，会一直判断链表中第一个线程是否取消或者中断，若是，则将其移除列队。并且会park线程（等待释放锁后会unpark第一个节点的线程，让这个链表中的线程开始去获取锁）如果成功，则释放当前节点并返回。

#### 公平锁：
线程去获取锁时，会先检查有无排队的线程再检查cms状态。所以新来的线程一定会放在链表的末尾进行排队（通过cms操作插入的，严格按顺序）。其余的操作一样

释放的时候，会将state-1,如果state(也就是c)为0，则表示已释放，如果不为0，说明还有线程在占用。
reentrantlock的可重入，就是通过记录获取锁的线程，如果获取锁的线程是当前线程，则可以继续执行，并且会使state+1,退出时减一，直到为0时，将获取锁的线程置空。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/07/reentrantlock/" data-id="cjydsg9hu000yz0nw0pghwatb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/16/java序列化/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          java序列化
        
      </div>
    </a>
  
  
    <a href="/2019/04/04/concurrentcache/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">concurrentcache</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现/">悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现/" style="font-size: 10px;">悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/22/跳表/">跳表</a>
          </li>
        
          <li>
            <a href="/2019/07/18/integer/">integer</a>
          </li>
        
          <li>
            <a href="/2019/07/16/lock/">lock</a>
          </li>
        
          <li>
            <a href="/2019/07/16/lock_20190718_210149/">lock</a>
          </li>
        
          <li>
            <a href="/2019/06/22/redis-cluster/">redis-cluster</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>