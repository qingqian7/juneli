<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>java序列化 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="文章结构本文将逐一的介绍几个情境，顺序如下面的列表。  序列化 ID 的问题 静态变量序列化 父类的序列化与 Transient 关键字 对敏感字段加密 序列化存储规则列表的每一部分讲述了一个单独的情境，读者可以分别查看。">
<meta property="og:type" content="article">
<meta property="og:title" content="java序列化">
<meta property="og:url" content="http://yoursite.com/2019/04/16/java序列化/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="文章结构本文将逐一的介绍几个情境，顺序如下面的列表。  序列化 ID 的问题 静态变量序列化 父类的序列化与 Transient 关键字 对敏感字段加密 序列化存储规则列表的每一部分讲述了一个单独的情境，读者可以分别查看。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://github.com/qingqian7/images/blob/master/serialization/1.png?raw=true">
<meta property="og:image" content="https://github.com/qingqian7/images/blob/master/serialization/2.png?raw=true">
<meta property="og:image" content="https://github.com/qingqian7/images/blob/master/serialization/3.png?raw=true">
<meta property="og:image" content="https://github.com/qingqian7/images/blob/master/serialization/4.png?raw=true">
<meta property="og:updated_time" content="2019-07-18T13:02:52.761Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java序列化">
<meta name="twitter:description" content="文章结构本文将逐一的介绍几个情境，顺序如下面的列表。  序列化 ID 的问题 静态变量序列化 父类的序列化与 Transient 关键字 对敏感字段加密 序列化存储规则列表的每一部分讲述了一个单独的情境，读者可以分别查看。">
<meta name="twitter:image" content="https://github.com/qingqian7/images/blob/master/serialization/1.png?raw=true">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java序列化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/java序列化/" class="article-date">
  <time datetime="2019-04-16T03:55:02.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java序列化
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>文章结构<br>本文将逐一的介绍几个情境，顺序如下面的列表。</p>
<ul>
<li>序列化 ID 的问题</li>
<li>静态变量序列化</li>
<li>父类的序列化与 Transient 关键字</li>
<li>对敏感字段加密</li>
<li>序列化存储规则<br>列表的每一部分讲述了一个单独的情境，读者可以分别查看。<a id="more"></a>
<h4 id="序列化-ID-问题"><a href="#序列化-ID-问题" class="headerlink" title="序列化 ID 问题"></a>序列化 ID 问题</h4>情境：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C 序列化为二进制数据再传给 B，B 反序列化得到 C。</li>
</ul>
<p>问题：C 对象的全类路径假设为 com.inout.Test，在 A 和 B 端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable 接口，但是反序列化时总是提示不成功。</p>
<p>解决：虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）。清单 1 中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</p>
<p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>
<p>当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID 。</p>
<p>如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，未作更改的类，就需要显式地定义一个名为serialVersionUID，类型为long的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。</p>
<h5 id="清单-1-相同功能代码不同序列化-ID-的类对比"><a href="#清单-1-相同功能代码不同序列化-ID-的类对比" class="headerlink" title="清单 1. 相同功能代码不同序列化 ID 的类对比"></a>清单 1. 相同功能代码不同序列化 ID 的类对比</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.inout;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class A implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.inout;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class A implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 2L;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。</p>
<p>特性使用案例</p>
<p>读者应该听过 Façade 模式，它是为应用程序提供统一的访问接口，案例程序中的 Client 客户端使用了该模式，案例程序结构图如图 1 所示<br><img src="https://github.com/qingqian7/images/blob/master/serialization/1.png?raw=true" alt="image1"><br>Client 端通过 Façade Object 才可以与业务逻辑对象进行交互。而客户端的 Façade Object 不能直接由 Client 生成，而是需要 Server 端生成，然后序列化后通过网络将二进制对象数据传给 Client，Client 负责反序列化得到 Façade 对象。该模式可以使得 Client 端程序的使用需要服务器端的许可，同时 Client 端和服务器端的 Façade Object 类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的 Façade Object 类的序列化 ID 再次生成，当 Client 端反序列化 Façade Object 就会失败，也就是强制 Client 端从服务器端获取最新程序。</p>
<h4 id="静态变量序列化"><a href="#静态变量序列化" class="headerlink" title="静态变量序列化"></a>静态变量序列化</h4><p> 情境：查看清单 2 的代码。</p>
<h5 id="清单-2-静态变量序列化问题代码"><a href="#清单-2-静态变量序列化问题代码" class="headerlink" title="清单 2. 静态变量序列化问题代码"></a>清单 2. 静态变量序列化问题代码</h5> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.inout;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class StaticMemberVarriableSerializable implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    public static int staticVar = 15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.inout;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">public class StaticMemberVarriableSerializableWrite &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 初始时staticVar为5</span><br><span class="line">            File file = new File(&quot;D:&quot; + File.separator + &quot;ss.txt&quot;);</span><br><span class="line">            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));</span><br><span class="line">            out.writeObject(new StaticMemberVarriableSerializable());</span><br><span class="line">            out.close();</span><br><span class="line"></span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 先将StaticMemberVarriableSerializable类序列化到d:\ss.txt文件中。</p>
<p> 接着读上面的文件进行反序列化啦：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.inout;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class StaticMemberVarriableSerializable implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    public static int staticVar = 15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.inout;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class StaticMemberVarriableSerializableRead &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            File file = new File(&quot;D:&quot; + File.separator + &quot;ss.txt&quot;);</span><br><span class="line">            ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file));</span><br><span class="line">            StaticMemberVarriableSerializable t = (StaticMemberVarriableSerializable) oin.readObject();</span><br><span class="line">            oin.close();</span><br><span class="line"></span><br><span class="line">            // 再读取，通过t.staticVar打印新的值</span><br><span class="line">            System.out.println(&quot;staticVar:&quot; + t.staticVar);</span><br><span class="line"></span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 结果：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure></p>
<p> 清单 2 中的 main 方法，将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照清单 2，这个 System.out.println(t.staticVar) 语句输出的是 15 还是 5 呢？</p>
<p> 最后的输出是 15，对于无法理解的读者认为，打印的 staticVar 是从读取的对象里获得的，应该是保存时的状态才对。之所以打印 10 的原因在于序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。</p>
<h4 id="父类的序列化与-Transient-关键字"><a href="#父类的序列化与-Transient-关键字" class="headerlink" title="父类的序列化与 Transient 关键字"></a>父类的序列化与 Transient 关键字</h4><p> 情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。</p>
<p> 解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。</p>
<p> Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p>
<p> 特性使用案例</p>
<p> 我们熟悉使用 Transient 关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。</p>
<p> 图 2. 案例程序类图<br> <img src="https://github.com/qingqian7/images/blob/master/serialization/2.png?raw=true" alt="image1"><br> 上图中可以看出，attr1、attr2、attr3、attr5 都不会被序列化，放在父类中的好处在于当有另外一个 Child 类时，attr1、attr2、attr3 依然不会被序列化，不用重复抒写 transient，代码简洁。</p>
<p> 代码清单：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.inout;</span><br><span class="line"></span><br><span class="line">public class Parent &#123;</span><br><span class="line"></span><br><span class="line">    private String attr1;</span><br><span class="line">    </span><br><span class="line">    private String attr2;</span><br><span class="line">    </span><br><span class="line">    private String attr3;</span><br><span class="line">    </span><br><span class="line">    public Parent() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Parent(String attr1, String attr2, String attr3) &#123;</span><br><span class="line">        this.attr1 = attr1;</span><br><span class="line">        this.attr2 = attr2;</span><br><span class="line">        this.attr3 = attr3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAttr1() &#123;</span><br><span class="line">        return attr1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAttr1(String attr1) &#123;</span><br><span class="line">        this.attr1 = attr1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAttr2() &#123;</span><br><span class="line">        return attr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAttr2(String attr2) &#123;</span><br><span class="line">        this.attr2 = attr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAttr3() &#123;</span><br><span class="line">        return attr3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAttr3(String attr3) &#123;</span><br><span class="line">        this.attr3 = attr3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.inout;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Child extends Parent implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private String attr4;</span><br><span class="line">    </span><br><span class="line">    private transient String attr5;</span><br><span class="line">    </span><br><span class="line">    public String getAttr4() &#123;</span><br><span class="line">        return attr4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAttr4(String attr4) &#123;</span><br><span class="line">        this.attr4 = attr4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAttr5() &#123;</span><br><span class="line">        return attr5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAttr5(String attr5) &#123;</span><br><span class="line">        this.attr5 = attr5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Child(String attr1, String attr2, String attr3, String attr4, String attr5) &#123;</span><br><span class="line">        super(attr1, attr2, attr3);</span><br><span class="line">        this.attr4 = attr4;</span><br><span class="line">        this.attr5 = attr5;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        File file = new File(&quot;D:&quot; + File.separator + &quot;s.txt&quot;);</span><br><span class="line">        OutputStream os = new FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(os);</span><br><span class="line">        oos.writeObject(new Child(&quot;str1&quot;, &quot;str2&quot;,&quot;str3&quot;, &quot;str4&quot;,&quot;str5&quot;));</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        InputStream is = new FileInputStream(file);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(is);</span><br><span class="line">        Child so = (Child) ois.readObject();</span><br><span class="line">        System.out.println(&quot;str1 = &quot; + so.getAttr1());</span><br><span class="line">        System.out.println(&quot;str2 = &quot; + so.getAttr2());</span><br><span class="line">        System.out.println(&quot;str3 = &quot; + so.getAttr3());</span><br><span class="line">        System.out.println(&quot;str4 = &quot; + so.getAttr4());</span><br><span class="line">        System.out.println(&quot;str5 = &quot; + so.getAttr5());</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 结果：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = null</span><br><span class="line">str2 = null</span><br><span class="line">str3 = null</span><br><span class="line">str4 = str4</span><br><span class="line">str5 = null</span><br></pre></td></tr></table></figure></p>
<h4 id="对敏感字段加密"><a href="#对敏感字段加密" class="headerlink" title="对敏感字段加密"></a>对敏感字段加密</h4><p> 情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p>
<p> 解决：在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，清单 3 展示了这个过程。</p>
<p> 代码清单：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.inout;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectInputStream.GetField;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.ObjectOutputStream.PutField;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class SensitiveEncryption implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    private String loginName;</span><br><span class="line">    </span><br><span class="line">    //private transient String password;</span><br><span class="line">    private String password;</span><br><span class="line">    </span><br><span class="line">    public SensitiveEncryption(String loginName, String password) &#123;</span><br><span class="line">        this.loginName = loginName;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void writeObject(ObjectOutputStream out) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            PutField putFields = out.putFields();</span><br><span class="line">            putFields.put(&quot;loginName&quot;, loginName);</span><br><span class="line">            System.out.println(&quot;原密码:&quot; + password);</span><br><span class="line">            password = &quot;encryption&quot;;//模拟加密</span><br><span class="line">            putFields.put(&quot;password&quot;, password);</span><br><span class="line">            System.out.println(&quot;加密后的密码&quot; + password);</span><br><span class="line">            out.writeFields();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void readObject(ObjectInputStream in) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            GetField readFields = in.readFields();</span><br><span class="line">            Object object1 = readFields.get(&quot;loginName&quot;, &quot;&quot;);</span><br><span class="line">            Object object2 = readFields.get(&quot;password&quot;, &quot;&quot;);</span><br><span class="line">            System.out.println(&quot;要解密的字符串:&quot; + object2.toString());</span><br><span class="line">            //password = &quot;pass&quot;;//模拟解密,需要获得本地的密钥</span><br><span class="line">            password = object2.toString();</span><br><span class="line">            loginName = object1.toString();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLoginName() &#123;</span><br><span class="line">        return loginName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLoginName(String loginName) &#123;</span><br><span class="line">        this.loginName = loginName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        File file = new File(&quot;D:&quot; + File.separator + &quot;sss.txt&quot;);</span><br><span class="line">        OutputStream os = new FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(os);</span><br><span class="line">        oos.writeObject(new SensitiveEncryption(&quot;str1&quot;, &quot;str2&quot;));</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        InputStream is = new FileInputStream(file);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(is);</span><br><span class="line">        SensitiveEncryption so = (SensitiveEncryption) ois.readObject();</span><br><span class="line">        System.out.println(&quot;loginName = &quot; + so.getLoginName());</span><br><span class="line">        System.out.println(&quot;password = &quot; + so.getPassword());</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 执行结果：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原密码:str2</span><br><span class="line">加密后的密码encryption</span><br><span class="line">要解密的字符串:encryption</span><br><span class="line">loginName = str1</span><br><span class="line">password = encryption</span><br></pre></td></tr></table></figure></p>
<p> 在清单 的 writeObject 方法中，对密码进行了加密，在 readObject 中则对 password 进行解密，只有拥有密钥的客户端，才可以正确的解析出密码，确保了数据的安全。</p>
<p> 特性使用案例</p>
<p> RMI 技术是完全基于 Java 序列化技术的，服务器端接口调用所需要的参数对象来至于客户端，它们通过网络相互传输。这就涉及 RMI 的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用本节介绍的方法在客户端对密码进行加密，服务器端进行解密，确保数据传输的安全性。</p>
<h4 id="序列化存储规则"><a href="#序列化存储规则" class="headerlink" title="序列化存储规则"></a>序列化存储规则</h4><p> 情境：问题代码如清单 4 所示。</p>
<p> 清单 4. 存储规则问题代码<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.inout;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class SerializableStore implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private String str1;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.obj&quot;));</span><br><span class="line">        SerializableStore test = new SerializableStore();</span><br><span class="line">        // 试图将对象两次写入文件</span><br><span class="line">        out.writeObject(test);</span><br><span class="line">        out.flush();</span><br><span class="line">        System.out.println(new File(&quot;result.obj&quot;).length());</span><br><span class="line">        out.writeObject(test);</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(new File(&quot;result.obj&quot;).length());</span><br><span class="line"></span><br><span class="line">        ObjectInputStream oin = new ObjectInputStream(new FileInputStream(&quot;result.obj&quot;));</span><br><span class="line">        // 从文件依次读出两个文件</span><br><span class="line">        SerializableStore t1 = (SerializableStore) oin.readObject();</span><br><span class="line">        SerializableStore t2 = (SerializableStore) oin.readObject();</span><br><span class="line">        oin.close();</span><br><span class="line"></span><br><span class="line">        // 判断两个引用是否指向同一个对象</span><br><span class="line">        System.out.println(t1 == t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>清单  中对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入 false 才对，但是最后结果输出如图 4 所示。</p>
<p>图 4. 示例程序输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">77</span><br><span class="line">82</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p>我们看到，第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是为什么呢？</p>
<p>解答：Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单  中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。</p>
<p>特性案例分析</p>
<p>查看清单 5 的代码。</p>
<h5 id="清单-5-案例代码"><a href="#清单-5-案例代码" class="headerlink" title="清单 5. 案例代码"></a>清单 5. 案例代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.obj&quot;));</span><br><span class="line">Test test = new Test();</span><br><span class="line">test.i = 1;</span><br><span class="line">out.writeObject(test);</span><br><span class="line">out.flush();</span><br><span class="line">test.i = 2;</span><br><span class="line">out.writeObject(test);</span><br><span class="line">out.close();</span><br><span class="line">ObjectInputStream oin = new ObjectInputStream(new FileInputStream(</span><br><span class="line">                    &quot;result.obj&quot;));</span><br><span class="line">Test t1 = (Test) oin.readObject();</span><br><span class="line">Test t2 = (Test) oin.readObject();</span><br><span class="line">System.out.println(t1.i);</span><br><span class="line">System.out.println(t2.i);</span><br></pre></td></tr></table></figure>

<p>清单 4 的目的是希望将 test 对象两次保存到 result.obj 文件中，写入一次以后修改对象属性值再次保存第二次，然后从 result.obj 中再依次读出两个对象，输出这两个对象的 i 属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。</p>
<p>结果两个输出的都是 1， 原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次 writeObject 需要特别注意这个问题。</p>
<h4 id="默认序列化"><a href="#默认序列化" class="headerlink" title="默认序列化"></a>默认序列化</h4><p>序列化只需要实现java.io.Serializable接口就可以了。序列化的时候有一个serialVersionUID参数，Java序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化，Java虚拟机会把传过来的字节流中的serialVersionUID和本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的实体类，可以进行反序列化，否则Java虚拟机会拒绝对这个实体类进行反序列化并抛出异常。serialVersionUID有两种生成方式：</p>
<p>1、默认的1L</p>
<p>2、根据类名、接口名、成员方法以及属性等来生成一个64位的Hash字段</p>
<p>如果实现java.io.Serializable接口的实体类没有显式定义一个名为serialVersionUID、类型为long的变量时，Java序列化机制会根据编译的.class文件自动生成一个serialVersionUID，如果.class文件没有变化，那么就算编译再多次，serialVersionUID也不会变化。换言之，Java为用户定义了默认的序列化、反序列化方法，其实就是ObjectOutputStream的defaultWriteObject方法和ObjectInputStream的defaultReadObject方法。</p>
<h4 id="手动指定序列化过程"><a href="#手动指定序列化过程" class="headerlink" title="手动指定序列化过程"></a>手动指定序列化过程</h4><p>Java并不强求用户非要使用默认的序列化方式，用户也可以按照自己的喜好自己指定自己想要的序列化方式—-只要你自己能保证序列化前后能得到想要的数据就好了。手动指定序列化方式的规则是：</p>
<p>进行序列化、反序列化时，虚拟机会首先试图调用对象里的writeObject和readObject方法，进行用户自定义的序列化和反序列化。如果没有这样的方法，那么默认调用的是ObjectOutputStream的defaultWriteObject以及ObjectInputStream的defaultReadObject方法。换言之，利用自定义的writeObject方法和readObject方法，用户可以自己控制序列化和反序列化的过程。</p>
<p>这是非常有用的。比如：</p>
<p>1、有些场景下，某些字段我们并不想要使用Java提供给我们的序列化方式，而是想要以自定义的方式去序列化它，比如ArrayList的 elementData、HashMap的table（至于为什么在之后写这两个类的时候会解释原因），就可以通过将这些字段声明为transient， 然后在writeObject和readObject中去使用自己想要的方式去序列化它们。</p>
<p>2、因为 序列化并不安全，因此有些场景下我们需要对一些敏感字段进行加密再序列化，然后再反序列化的时候按照同样的方式进行解密，就在一定程度上保证了安全性了。 要这么做，就必须自己写writeObject和readObject，writeObject方法在序列化前对字段加密，readObject方法在序 列化之后对字段解密。</p>
<p>上面的例子SerializObject这个类修改一下，主函数不需要修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.dxz.serializable;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class SerializableObject implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    private String str0;</span><br><span class="line">    private transient String str1;</span><br><span class="line">    private static String str2 = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">    public SerializableObject(String str0, String str1) &#123;</span><br><span class="line">        this.str0 = str0;</span><br><span class="line">        this.str1 = str1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getStr0() &#123;</span><br><span class="line">        return str0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getStr1() &#123;</span><br><span class="line">        return str1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;我想自己控制序列化的过程&quot;);</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(str1.length());</span><br><span class="line">        for (int i = 0; i &lt; str1.length(); i++)</span><br><span class="line">            s.writeChar(str1.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void readObject(java.io.ObjectInputStream s) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;我想自己控制反序列化的过程&quot;);</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        int length = s.readInt();</span><br><span class="line">        char[] cs = new char[length];</span><br><span class="line">        for (int i = 0; i &lt; length; i++)</span><br><span class="line">            cs[i] = s.readChar();</span><br><span class="line">        str1 = new String(cs, 0, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        File file = new File(&quot;D:&quot; + File.separator + &quot;s.txt&quot;);</span><br><span class="line">        OutputStream os = new FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(os);</span><br><span class="line">        oos.writeObject(new SerializableObject(&quot;str0&quot;, &quot;str1&quot;));</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        InputStream is = new FileInputStream(file);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(is);</span><br><span class="line">        SerializableObject so = (SerializableObject) ois.readObject();</span><br><span class="line">        System.out.println(&quot;str0 = &quot; + so.getStr0());</span><br><span class="line">        System.out.println(&quot;str1 = &quot; + so.getStr1());</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接看一下运行结果</p>
<p>我想自己控制序列化的过程<br>我想自己控制反序列化的过程<br>str0 = str0<br>str1 = str1<br>看到，程序走到了我们自己写的writeObject和readObject中，而且被transient修饰的str1也成功序列化、反序列化出来了—-因为手动将str1写入了文件和从文件中读了出来.<br>先通过defaultWriteObject和defaultReadObject方法序列化、反序列化，然后在文件结尾追加需要额外序列化的内容/从文件的结尾读取额外需要读取的内容。 </p>
<h5 id="我们自己写的writeObject和readObject为什么会被调用？"><a href="#我们自己写的writeObject和readObject为什么会被调用？" class="headerlink" title="我们自己写的writeObject和readObject为什么会被调用？"></a>我们自己写的writeObject和readObject为什么会被调用？</h5><p>在ObjectStreamClass.java中会通过反射查找目标对象是否有writeObject和readObject方法，如下图：<br><img src="https://github.com/qingqian7/images/blob/master/serialization/3.png?raw=true" alt="image1"><br>如果有就调用，否则调用<br><img src="https://github.com/qingqian7/images/blob/master/serialization/4.png?raw=true" alt="image1"></p>
<h4 id="复杂序列化情况总结"><a href="#复杂序列化情况总结" class="headerlink" title="复杂序列化情况总结"></a>复杂序列化情况总结</h4><p>虽然Java的序列化能够保证对象状态的持久保存，但是遇到一些对象结构复杂的情况还是比较难处理的，最后对一些复杂的对象情况作一个总结：</p>
<p>1、当父类继承Serializable接口时，所有子类都可以被序列化</p>
<p>2、子类实现了Serializable接口，父类没有，父类需要有默认的构造函数，父类中的属性不能序列化（不报错，数据丢失），但是在子类中属性仍能正确序列化</p>
<p>3、如果序列化的属性是对象，则这个对象也必须实现Serializable接口，否则会报错</p>
<p>4、反序列化时，如果对象的属性有修改或删减，则修改的部分属性会丢失，但不会报错</p>
<p>5、反序列化时，如果serialVersionUID被修改，则反序列化时会失败</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/16/java序列化/" data-id="cjydsg9hk000uz0nwetbdj3cm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/18/zookeeperlock/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          zookeeperlock
        
      </div>
    </a>
  
  
    <a href="/2019/04/07/reentrantlock/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">reentrantlock</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现/">悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现/" style="font-size: 10px;">悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/22/跳表/">跳表</a>
          </li>
        
          <li>
            <a href="/2019/07/18/integer/">integer</a>
          </li>
        
          <li>
            <a href="/2019/07/16/lock/">lock</a>
          </li>
        
          <li>
            <a href="/2019/07/16/lock_20190718_210149/">lock</a>
          </li>
        
          <li>
            <a href="/2019/06/22/redis-cluster/">redis-cluster</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>