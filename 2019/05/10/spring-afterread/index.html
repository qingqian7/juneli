<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>spring_afterread | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="花了10多天把spring源码分析的关于ioc部分看了两遍，第一遍看的时候，还是有些看的云里雾里的，不知道有些地方这么处理的作用和为什么要这么处理。看完一遍之后，去网上找了些demo来拓展spring，然后又下载了spring源码导入到idea，然后边看源码分析边对比，才算是弄懂了一些。当然还是有很多地方没弄懂，有待后续继续阅读。这里先写一些读后收获。">
<meta property="og:type" content="article">
<meta property="og:title" content="spring_afterread">
<meta property="og:url" content="http://yoursite.com/2019/05/10/spring-afterread/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="花了10多天把spring源码分析的关于ioc部分看了两遍，第一遍看的时候，还是有些看的云里雾里的，不知道有些地方这么处理的作用和为什么要这么处理。看完一遍之后，去网上找了些demo来拓展spring，然后又下载了spring源码导入到idea，然后边看源码分析边对比，才算是弄懂了一些。当然还是有很多地方没弄懂，有待后续继续阅读。这里先写一些读后收获。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://github.com/qingqian7/images/blob/master/spring_afterread/1.png?raw=true">
<meta property="og:image" content="https://github.com/qingqian7/images/blob/master/spring_afterread/2.png?raw=true">
<meta property="og:updated_time" content="2019-07-18T13:02:50.848Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring_afterread">
<meta name="twitter:description" content="花了10多天把spring源码分析的关于ioc部分看了两遍，第一遍看的时候，还是有些看的云里雾里的，不知道有些地方这么处理的作用和为什么要这么处理。看完一遍之后，去网上找了些demo来拓展spring，然后又下载了spring源码导入到idea，然后边看源码分析边对比，才算是弄懂了一些。当然还是有很多地方没弄懂，有待后续继续阅读。这里先写一些读后收获。">
<meta name="twitter:image" content="https://github.com/qingqian7/images/blob/master/spring_afterread/1.png?raw=true">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-spring-afterread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/10/spring-afterread/" class="article-date">
  <time datetime="2019-05-10T06:09:50.000Z" itemprop="datePublished">2019-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      spring_afterread
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>花了10多天把spring源码分析的关于ioc部分看了两遍，第一遍看的时候，还是有些看的云里雾里的，不知道有些地方这么处理的作用和为什么要这么处理。看完一遍之后，去网上找了些demo来拓展spring，然后又下载了spring源码导入到idea，然后边看源码分析边对比，才算是弄懂了一些。当然还是有很多地方没弄懂，有待后续继续阅读。这里先写一些读后收获。</p>
<a id="more"></a>
<h3 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h3><p>DefaultListableBeanFactory是整个bean加载的核心部分，是spring注册以及加载bean的默认实现，XmlBeanFactory与DefaultListableBeanFactory的不同之处在于xmlBeanFactory使用了自定义的xml读取器XmlBeanDefinitionReader,实现了个性化的BeanDefinitionReader读取。<br>首先看下DefaultListableBeanFactory源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory</span><br><span class="line">		implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	private static Class&lt;?&gt; javaxInjectProviderClass;</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			javaxInjectProviderClass =</span><br><span class="line">					ClassUtils.forName(&quot;javax.inject.Provider&quot;, DefaultListableBeanFactory.class.getClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			// JSR-330 API not available - Provider interface simply not supported then.</span><br><span class="line">			javaxInjectProviderClass = null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/** Map from serialized id to factory instance. */</span><br><span class="line">	private static final Map&lt;String, Reference&lt;DefaultListableBeanFactory&gt;&gt; serializableFactories =</span><br><span class="line">			new ConcurrentHashMap&lt;&gt;(8);</span><br><span class="line"></span><br><span class="line">	/** Optional id for this factory, for serialization purposes. */</span><br><span class="line">	@Nullable</span><br><span class="line">	private String serializationId;</span><br><span class="line"></span><br><span class="line">	/** Whether to allow re-registration of a different definition with the same name. */</span><br><span class="line">	private boolean allowBeanDefinitionOverriding = true;</span><br><span class="line"></span><br><span class="line">	/** Whether to allow eager class loading even for lazy-init beans. */</span><br><span class="line">	private boolean allowEagerClassLoading = true;</span><br><span class="line"></span><br><span class="line">	/** Optional OrderComparator for dependency Lists and arrays. */</span><br><span class="line">	@Nullable</span><br><span class="line">	private Comparator&lt;Object&gt; dependencyComparator;</span><br><span class="line"></span><br><span class="line">	/** Resolver to use for checking if a bean definition is an autowire candidate. */</span><br><span class="line">	private AutowireCandidateResolver autowireCandidateResolver = new SimpleAutowireCandidateResolver();</span><br><span class="line"></span><br><span class="line">	/** Map from dependency type to corresponding autowired value. */</span><br><span class="line">	private final Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = new ConcurrentHashMap&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">	/** Map of bean definition objects, keyed by bean name. */</span><br><span class="line">	private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">	/** Map of singleton and non-singleton bean names, keyed by dependency type. */</span><br><span class="line">	private final Map&lt;Class&lt;?&gt;, String[]&gt; allBeanNamesByType = new ConcurrentHashMap&lt;&gt;(64);</span><br><span class="line"></span><br><span class="line">	/** Map of singleton-only bean names, keyed by dependency type. */</span><br><span class="line">	private final Map&lt;Class&lt;?&gt;, String[]&gt; singletonBeanNamesByType = new ConcurrentHashMap&lt;&gt;(64);</span><br><span class="line"></span><br><span class="line">	/** List of bean definition names, in registration order. */</span><br><span class="line">	private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">	/** List of names of manually registered singletons, in registration order. */</span><br><span class="line">	private volatile Set&lt;String&gt; manualSingletonNames = new LinkedHashSet&lt;&gt;(16);</span><br><span class="line"></span><br><span class="line">	/** Cached array of bean definition names in case of frozen configuration. */</span><br><span class="line">	@Nullable</span><br><span class="line">	private volatile String[] frozenBeanDefinitionNames;</span><br><span class="line"></span><br><span class="line">	/** Whether bean definition metadata may be cached for all beans. */</span><br><span class="line">	private volatile boolean configurationFrozen = false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Create a new DefaultListableBeanFactory.</span><br><span class="line">	 */</span><br><span class="line">	public DefaultListableBeanFactory() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Create a new DefaultListableBeanFactory with the given parent.</span><br><span class="line">	 * @param parentBeanFactory the parent BeanFactory</span><br><span class="line">	 */</span><br><span class="line">	public DefaultListableBeanFactory(@Nullable BeanFactory parentBeanFactory) &#123;</span><br><span class="line">		super(parentBeanFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Specify an id for serialization purposes, allowing this BeanFactory to be</span><br><span class="line">	 * deserialized from this id back into the BeanFactory object, if needed.</span><br><span class="line">	 */</span><br><span class="line">	public void setSerializationId(@Nullable String serializationId) &#123;</span><br><span class="line">		if (serializationId != null) &#123;</span><br><span class="line">			serializableFactories.put(serializationId, new WeakReference&lt;&gt;(this));</span><br><span class="line">		&#125;</span><br><span class="line">		else if (this.serializationId != null) &#123;</span><br><span class="line">			serializableFactories.remove(this.serializationId);</span><br><span class="line">		&#125;</span><br><span class="line">		this.serializationId = serializationId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return an id for serialization purposes, if specified, allowing this BeanFactory</span><br><span class="line">	 * to be deserialized from this id back into the BeanFactory object, if needed.</span><br><span class="line">	 * @since 4.1.2</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	public String getSerializationId() &#123;</span><br><span class="line">		return this.serializationId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set whether it should be allowed to override bean definitions by registering</span><br><span class="line">	 * a different definition with the same name, automatically replacing the former.</span><br><span class="line">	 * If not, an exception will be thrown. This also applies to overriding aliases.</span><br><span class="line">	 * &lt;p&gt;Default is &quot;true&quot;.</span><br><span class="line">	 * @see #registerBeanDefinition</span><br><span class="line">	 */</span><br><span class="line">	public void setAllowBeanDefinitionOverriding(boolean allowBeanDefinitionOverriding) &#123;</span><br><span class="line">		this.allowBeanDefinitionOverriding = allowBeanDefinitionOverriding;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return whether it should be allowed to override bean definitions by registering</span><br><span class="line">	 * a different definition with the same name, automatically replacing the former.</span><br><span class="line">	 * @since 4.1.2</span><br><span class="line">	 */</span><br><span class="line">	public boolean isAllowBeanDefinitionOverriding() &#123;</span><br><span class="line">		return this.allowBeanDefinitionOverriding;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set whether the factory is allowed to eagerly load bean classes</span><br><span class="line">	 * even for bean definitions that are marked as &quot;lazy-init&quot;.</span><br><span class="line">	 * &lt;p&gt;Default is &quot;true&quot;. Turn this flag off to suppress class loading</span><br><span class="line">	 * for lazy-init beans unless such a bean is explicitly requested.</span><br><span class="line">	 * In particular, by-type lookups will then simply ignore bean definitions</span><br><span class="line">	 * without resolved class name, instead of loading the bean classes on</span><br><span class="line">	 * demand just to perform a type check.</span><br><span class="line">	 * @see AbstractBeanDefinition#setLazyInit</span><br><span class="line">	 */</span><br><span class="line">	public void setAllowEagerClassLoading(boolean allowEagerClassLoading) &#123;</span><br><span class="line">		this.allowEagerClassLoading = allowEagerClassLoading;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return whether the factory is allowed to eagerly load bean classes</span><br><span class="line">	 * even for bean definitions that are marked as &quot;lazy-init&quot;.</span><br><span class="line">	 * @since 4.1.2</span><br><span class="line">	 */</span><br><span class="line">	public boolean isAllowEagerClassLoading() &#123;</span><br><span class="line">		return this.allowEagerClassLoading;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set a &#123;@link java.util.Comparator&#125; for dependency Lists and arrays.</span><br><span class="line">	 * @since 4.0</span><br><span class="line">	 * @see org.springframework.core.OrderComparator</span><br><span class="line">	 * @see org.springframework.core.annotation.AnnotationAwareOrderComparator</span><br><span class="line">	 */</span><br><span class="line">	public void setDependencyComparator(@Nullable Comparator&lt;Object&gt; dependencyComparator) &#123;</span><br><span class="line">		this.dependencyComparator = dependencyComparator;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the dependency comparator for this BeanFactory (may be &#123;@code null&#125;.</span><br><span class="line">	 * @since 4.0</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	public Comparator&lt;Object&gt; getDependencyComparator() &#123;</span><br><span class="line">		return this.dependencyComparator;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set a custom autowire candidate resolver for this BeanFactory to use</span><br><span class="line">	 * when deciding whether a bean definition should be considered as a</span><br><span class="line">	 * candidate for autowiring.</span><br><span class="line">	 */</span><br><span class="line">	public void setAutowireCandidateResolver(final AutowireCandidateResolver autowireCandidateResolver) &#123;</span><br><span class="line">		Assert.notNull(autowireCandidateResolver, &quot;AutowireCandidateResolver must not be null&quot;);</span><br><span class="line">		if (autowireCandidateResolver instanceof BeanFactoryAware) &#123;</span><br><span class="line">			if (System.getSecurityManager() != null) &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">					((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(DefaultListableBeanFactory.this);</span><br><span class="line">					return null;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				((BeanFactoryAware) autowireCandidateResolver).setBeanFactory(this);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		this.autowireCandidateResolver = autowireCandidateResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the autowire candidate resolver for this BeanFactory (never &#123;@code null&#125;).</span><br><span class="line">	 */</span><br><span class="line">	public AutowireCandidateResolver getAutowireCandidateResolver() &#123;</span><br><span class="line">		return this.autowireCandidateResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void copyConfigurationFrom(ConfigurableBeanFactory otherFactory) &#123;</span><br><span class="line">		super.copyConfigurationFrom(otherFactory);</span><br><span class="line">		if (otherFactory instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">			DefaultListableBeanFactory otherListableFactory = (DefaultListableBeanFactory) otherFactory;</span><br><span class="line">			this.allowBeanDefinitionOverriding = otherListableFactory.allowBeanDefinitionOverriding;</span><br><span class="line">			this.allowEagerClassLoading = otherListableFactory.allowEagerClassLoading;</span><br><span class="line">			this.dependencyComparator = otherListableFactory.dependencyComparator;</span><br><span class="line">			// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware...</span><br><span class="line">			setAutowireCandidateResolver(BeanUtils.instantiateClass(getAutowireCandidateResolver().getClass()));</span><br><span class="line">			// Make resolvable dependencies (e.g. ResourceLoader) available here as well...</span><br><span class="line">			this.resolvableDependencies.putAll(otherListableFactory.resolvableDependencies);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//---------------------------------------------------------------------</span><br><span class="line">	// Implementation of remaining BeanFactory methods</span><br><span class="line">	//---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException &#123;</span><br><span class="line">		return getBean(requiredType, (Object[]) null);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, @Nullable Object... args) throws BeansException &#123;</span><br><span class="line">		Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);</span><br><span class="line">		if (resolved == null) &#123;</span><br><span class="line">			throw new NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">		&#125;</span><br><span class="line">		return (T) resolved;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(Class&lt;T&gt; requiredType) throws BeansException &#123;</span><br><span class="line">		return getBeanProvider(ResolvableType.forRawClass(requiredType));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T&gt; ObjectProvider&lt;T&gt; getBeanProvider(ResolvableType requiredType) &#123;</span><br><span class="line">		return new BeanObjectProvider&lt;T&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public T getObject() throws BeansException &#123;</span><br><span class="line">				T resolved = resolveBean(requiredType, null, false);</span><br><span class="line">				if (resolved == null) &#123;</span><br><span class="line">					throw new NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">				&#125;</span><br><span class="line">				return resolved;</span><br><span class="line">			&#125;</span><br><span class="line">			@Override</span><br><span class="line">			public T getObject(Object... args) throws BeansException &#123;</span><br><span class="line">				T resolved = resolveBean(requiredType, args, false);</span><br><span class="line">				if (resolved == null) &#123;</span><br><span class="line">					throw new NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">				&#125;</span><br><span class="line">				return resolved;</span><br><span class="line">			&#125;</span><br><span class="line">			@Override</span><br><span class="line">			@Nullable</span><br><span class="line">			public T getIfAvailable() throws BeansException &#123;</span><br><span class="line">				return resolveBean(requiredType, null, false);</span><br><span class="line">			&#125;</span><br><span class="line">			@Override</span><br><span class="line">			@Nullable</span><br><span class="line">			public T getIfUnique() throws BeansException &#123;</span><br><span class="line">				return resolveBean(requiredType, null, true);</span><br><span class="line">			&#125;</span><br><span class="line">			@Override</span><br><span class="line">			public Stream&lt;T&gt; stream() &#123;</span><br><span class="line">				return Arrays.stream(getBeanNamesForTypedStream(requiredType))</span><br><span class="line">						.map(name -&gt; (T) getBean(name))</span><br><span class="line">						.filter(bean -&gt; !(bean instanceof NullBean));</span><br><span class="line">			&#125;</span><br><span class="line">			@Override</span><br><span class="line">			public Stream&lt;T&gt; orderedStream() &#123;</span><br><span class="line">				String[] beanNames = getBeanNamesForTypedStream(requiredType);</span><br><span class="line">				Map&lt;String, T&gt; matchingBeans = new LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">				for (String beanName : beanNames) &#123;</span><br><span class="line">					Object beanInstance = getBean(beanName);</span><br><span class="line">					if (!(beanInstance instanceof NullBean)) &#123;</span><br><span class="line">						matchingBeans.put(beanName, (T) beanInstance);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				Stream&lt;T&gt; stream = matchingBeans.values().stream();</span><br><span class="line">				return stream.sorted(adaptOrderComparator(matchingBeans));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Nullable</span><br><span class="line">	private &lt;T&gt; T resolveBean(ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) &#123;</span><br><span class="line">		NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);</span><br><span class="line">		if (namedBean != null) &#123;</span><br><span class="line">			return namedBean.getBeanInstance();</span><br><span class="line">		&#125;</span><br><span class="line">		BeanFactory parent = getParentBeanFactory();</span><br><span class="line">		if (parent instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">			return ((DefaultListableBeanFactory) parent).resolveBean(requiredType, args, nonUniqueAsNull);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (parent != null) &#123;</span><br><span class="line">			ObjectProvider&lt;T&gt; parentProvider = parent.getBeanProvider(requiredType);</span><br><span class="line">			if (args != null) &#123;</span><br><span class="line">				return parentProvider.getObject(args);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				return (nonUniqueAsNull ? parentProvider.getIfUnique() : parentProvider.getIfAvailable());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private String[] getBeanNamesForTypedStream(ResolvableType requiredType) &#123;</span><br><span class="line">		return BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this, requiredType);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//---------------------------------------------------------------------</span><br><span class="line">	// Implementation of ListableBeanFactory interface</span><br><span class="line">	//---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean containsBeanDefinition(String beanName) &#123;</span><br><span class="line">		Assert.notNull(beanName, &quot;Bean name must not be null&quot;);</span><br><span class="line">		return this.beanDefinitionMap.containsKey(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int getBeanDefinitionCount() &#123;</span><br><span class="line">		return this.beanDefinitionMap.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String[] getBeanDefinitionNames() &#123;</span><br><span class="line">		String[] frozenNames = this.frozenBeanDefinitionNames;</span><br><span class="line">		if (frozenNames != null) &#123;</span><br><span class="line">			return frozenNames.clone();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return StringUtils.toStringArray(this.beanDefinitionNames);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String[] getBeanNamesForType(ResolvableType type) &#123;</span><br><span class="line">		Class&lt;?&gt; resolved = type.resolve();</span><br><span class="line">		if (resolved != null &amp;&amp; !type.hasGenerics()) &#123;</span><br><span class="line">			return getBeanNamesForType(resolved, true, true);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return doGetBeanNamesForType(type, true, true);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String[] getBeanNamesForType(@Nullable Class&lt;?&gt; type) &#123;</span><br><span class="line">		return getBeanNamesForType(type, true, true);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String[] getBeanNamesForType(@Nullable Class&lt;?&gt; type, boolean includeNonSingletons, boolean allowEagerInit) &#123;</span><br><span class="line">		if (!isConfigurationFrozen() || type == null || !allowEagerInit) &#123;</span><br><span class="line">			return doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;Class&lt;?&gt;, String[]&gt; cache =</span><br><span class="line">				(includeNonSingletons ? this.allBeanNamesByType : this.singletonBeanNamesByType);</span><br><span class="line">		String[] resolvedBeanNames = cache.get(type);</span><br><span class="line">		if (resolvedBeanNames != null) &#123;</span><br><span class="line">			return resolvedBeanNames;</span><br><span class="line">		&#125;</span><br><span class="line">		resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, true);</span><br><span class="line">		if (ClassUtils.isCacheSafe(type, getBeanClassLoader())) &#123;</span><br><span class="line">			cache.put(type, resolvedBeanNames);</span><br><span class="line">		&#125;</span><br><span class="line">		return resolvedBeanNames;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private String[] doGetBeanNamesForType(ResolvableType type, boolean includeNonSingletons, boolean allowEagerInit) &#123;</span><br><span class="line">		List&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		// Check all bean definitions.</span><br><span class="line">		for (String beanName : this.beanDefinitionNames) &#123;</span><br><span class="line">			// Only consider bean as eligible if the bean name</span><br><span class="line">			// is not defined as alias for some other bean.</span><br><span class="line">			if (!isAlias(beanName)) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">					// Only check bean definition if it is complete.</span><br><span class="line">					if (!mbd.isAbstract() &amp;&amp; (allowEagerInit ||</span><br><span class="line">							(mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading()) &amp;&amp;</span><br><span class="line">									!requiresEagerInitForType(mbd.getFactoryBeanName()))) &#123;</span><br><span class="line">						// In case of FactoryBean, match object created by FactoryBean.</span><br><span class="line">						boolean isFactoryBean = isFactoryBean(beanName, mbd);</span><br><span class="line">						BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line">						boolean matchFound =</span><br><span class="line">								(allowEagerInit || !isFactoryBean ||</span><br><span class="line">										(dbd != null &amp;&amp; !mbd.isLazyInit()) || containsSingleton(beanName)) &amp;&amp;</span><br><span class="line">								(includeNonSingletons ||</span><br><span class="line">										(dbd != null ? mbd.isSingleton() : isSingleton(beanName))) &amp;&amp;</span><br><span class="line">								isTypeMatch(beanName, type);</span><br><span class="line">						if (!matchFound &amp;&amp; isFactoryBean) &#123;</span><br><span class="line">							// In case of FactoryBean, try to match FactoryBean instance itself next.</span><br><span class="line">							beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">							matchFound = (includeNonSingletons || mbd.isSingleton()) &amp;&amp; isTypeMatch(beanName, type);</span><br><span class="line">						&#125;</span><br><span class="line">						if (matchFound) &#123;</span><br><span class="line">							result.add(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				catch (CannotLoadBeanClassException ex) &#123;</span><br><span class="line">					if (allowEagerInit) &#123;</span><br><span class="line">						throw ex;</span><br><span class="line">					&#125;</span><br><span class="line">					// Probably a class name with a placeholder: let&apos;s ignore it for type matching purposes.</span><br><span class="line">					if (logger.isTraceEnabled()) &#123;</span><br><span class="line">						logger.trace(&quot;Ignoring bean class loading failure for bean &apos;&quot; + beanName + &quot;&apos;&quot;, ex);</span><br><span class="line">					&#125;</span><br><span class="line">					onSuppressedException(ex);</span><br><span class="line">				&#125;</span><br><span class="line">				catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">					if (allowEagerInit) &#123;</span><br><span class="line">						throw ex;</span><br><span class="line">					&#125;</span><br><span class="line">					// Probably some metadata with a placeholder: let&apos;s ignore it for type matching purposes.</span><br><span class="line">					if (logger.isTraceEnabled()) &#123;</span><br><span class="line">						logger.trace(&quot;Ignoring unresolvable metadata in bean definition &apos;&quot; + beanName + &quot;&apos;&quot;, ex);</span><br><span class="line">					&#125;</span><br><span class="line">					onSuppressedException(ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Check manually registered singletons too.</span><br><span class="line">		for (String beanName : this.manualSingletonNames) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				// In case of FactoryBean, match object created by FactoryBean.</span><br><span class="line">				if (isFactoryBean(beanName)) &#123;</span><br><span class="line">					if ((includeNonSingletons || isSingleton(beanName)) &amp;&amp; isTypeMatch(beanName, type)) &#123;</span><br><span class="line">						result.add(beanName);</span><br><span class="line">						// Match found for this bean: do not match FactoryBean itself anymore.</span><br><span class="line">						continue;</span><br><span class="line">					&#125;</span><br><span class="line">					// In case of FactoryBean, try to match FactoryBean itself next.</span><br><span class="line">					beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">				&#125;</span><br><span class="line">				// Match raw bean instance (might be raw FactoryBean).</span><br><span class="line">				if (isTypeMatch(beanName, type)) &#123;</span><br><span class="line">					result.add(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">				// Shouldn&apos;t happen - probably a result of circular reference resolution...</span><br><span class="line">				if (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(&quot;Failed to check manually registered singleton with name &apos;&quot; + beanName + &quot;&apos;&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return StringUtils.toStringArray(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Check whether the specified bean would need to be eagerly initialized</span><br><span class="line">	 * in order to determine its type.</span><br><span class="line">	 * @param factoryBeanName a factory-bean reference that the bean definition</span><br><span class="line">	 * defines a factory method for</span><br><span class="line">	 * @return whether eager initialization is necessary</span><br><span class="line">	 */</span><br><span class="line">	private boolean requiresEagerInitForType(@Nullable String factoryBeanName) &#123;</span><br><span class="line">		return (factoryBeanName != null &amp;&amp; isFactoryBean(factoryBeanName) &amp;&amp; !containsSingleton(factoryBeanName));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(@Nullable Class&lt;T&gt; type) throws BeansException &#123;</span><br><span class="line">		return getBeansOfType(type, true, true);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	public &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(@Nullable Class&lt;T&gt; type, boolean includeNonSingletons, boolean allowEagerInit)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		String[] beanNames = getBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">		Map&lt;String, T&gt; result = new LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Object beanInstance = getBean(beanName);</span><br><span class="line">				if (!(beanInstance instanceof NullBean)) &#123;</span><br><span class="line">					result.put(beanName, (T) beanInstance);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (BeanCreationException ex) &#123;</span><br><span class="line">				Throwable rootCause = ex.getMostSpecificCause();</span><br><span class="line">				if (rootCause instanceof BeanCurrentlyInCreationException) &#123;</span><br><span class="line">					BeanCreationException bce = (BeanCreationException) rootCause;</span><br><span class="line">					String exBeanName = bce.getBeanName();</span><br><span class="line">					if (exBeanName != null &amp;&amp; isCurrentlyInCreation(exBeanName)) &#123;</span><br><span class="line">						if (logger.isTraceEnabled()) &#123;</span><br><span class="line">							logger.trace(&quot;Ignoring match to currently created bean &apos;&quot; + exBeanName + &quot;&apos;: &quot; +</span><br><span class="line">									ex.getMessage());</span><br><span class="line">						&#125;</span><br><span class="line">						onSuppressedException(ex);</span><br><span class="line">						// Ignore: indicates a circular reference when autowiring constructors.</span><br><span class="line">						// We want to find matches other than the currently created bean itself.</span><br><span class="line">						continue;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType) &#123;</span><br><span class="line">		List&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String beanName : this.beanDefinitionNames) &#123;</span><br><span class="line">			BeanDefinition beanDefinition = getBeanDefinition(beanName);</span><br><span class="line">			if (!beanDefinition.isAbstract() &amp;&amp; findAnnotationOnBean(beanName, annotationType) != null) &#123;</span><br><span class="line">				result.add(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for (String beanName : this.manualSingletonNames) &#123;</span><br><span class="line">			if (!result.contains(beanName) &amp;&amp; findAnnotationOnBean(beanName, annotationType) != null) &#123;</span><br><span class="line">				result.add(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return StringUtils.toStringArray(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Map&lt;String, Object&gt; getBeansWithAnnotation(Class&lt;? extends Annotation&gt; annotationType) &#123;</span><br><span class="line">		String[] beanNames = getBeanNamesForAnnotation(annotationType);</span><br><span class="line">		Map&lt;String, Object&gt; result = new LinkedHashMap&lt;&gt;(beanNames.length);</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			Object beanInstance = getBean(beanName);</span><br><span class="line">			if (!(beanInstance instanceof NullBean)) &#123;</span><br><span class="line">				result.put(beanName, beanInstance);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	@Nullable</span><br><span class="line">	public &lt;A extends Annotation&gt; A findAnnotationOnBean(String beanName, Class&lt;A&gt; annotationType)</span><br><span class="line">			throws NoSuchBeanDefinitionException &#123;</span><br><span class="line"></span><br><span class="line">		return findMergedAnnotationOnBean(beanName, annotationType)</span><br><span class="line">				.synthesize(MergedAnnotation::isPresent).orElse(null);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private &lt;A extends Annotation&gt; MergedAnnotation&lt;A&gt; findMergedAnnotationOnBean(</span><br><span class="line">			String beanName, Class&lt;A&gt; annotationType) &#123;</span><br><span class="line"></span><br><span class="line">		Class&lt;?&gt; beanType = getType(beanName);</span><br><span class="line">		if (beanType != null) &#123;</span><br><span class="line">			MergedAnnotation&lt;A&gt; annotation =</span><br><span class="line">					MergedAnnotations.from(beanType, SearchStrategy.EXHAUSTIVE).get(annotationType);</span><br><span class="line">			if (annotation.isPresent()) &#123;</span><br><span class="line">				return annotation;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			// Check raw bean class, e.g. in case of a proxy.</span><br><span class="line">			if (bd.hasBeanClass()) &#123;</span><br><span class="line">				Class&lt;?&gt; beanClass = bd.getBeanClass();</span><br><span class="line">				if (beanClass != beanType) &#123;</span><br><span class="line">					MergedAnnotation&lt;A&gt; annotation =</span><br><span class="line">							MergedAnnotations.from(beanClass, SearchStrategy.EXHAUSTIVE).get(annotationType);</span><br><span class="line">					if (annotation.isPresent()) &#123;</span><br><span class="line">						return annotation;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// Check annotations declared on factory method, if any.</span><br><span class="line">			Method factoryMethod = bd.getResolvedFactoryMethod();</span><br><span class="line">			if (factoryMethod != null) &#123;</span><br><span class="line">				MergedAnnotation&lt;A&gt; annotation =</span><br><span class="line">						MergedAnnotations.from(factoryMethod, SearchStrategy.EXHAUSTIVE).get(annotationType);</span><br><span class="line">				if (annotation.isPresent()) &#123;</span><br><span class="line">					return annotation;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return MergedAnnotation.missing();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//---------------------------------------------------------------------</span><br><span class="line">	// Implementation of ConfigurableListableBeanFactory interface</span><br><span class="line">	//---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void registerResolvableDependency(Class&lt;?&gt; dependencyType, @Nullable Object autowiredValue) &#123;</span><br><span class="line">		Assert.notNull(dependencyType, &quot;Dependency type must not be null&quot;);</span><br><span class="line">		if (autowiredValue != null) &#123;</span><br><span class="line">			if (!(autowiredValue instanceof ObjectFactory || dependencyType.isInstance(autowiredValue))) &#123;</span><br><span class="line">				throw new IllegalArgumentException(&quot;Value [&quot; + autowiredValue +</span><br><span class="line">						&quot;] does not implement specified dependency type [&quot; + dependencyType.getName() + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			this.resolvableDependencies.put(dependencyType, autowiredValue);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor)</span><br><span class="line">			throws NoSuchBeanDefinitionException &#123;</span><br><span class="line"></span><br><span class="line">		return isAutowireCandidate(beanName, descriptor, getAutowireCandidateResolver());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Determine whether the specified bean definition qualifies as an autowire candidate,</span><br><span class="line">	 * to be injected into other beans which declare a dependency of matching type.</span><br><span class="line">	 * @param beanName the name of the bean definition to check</span><br><span class="line">	 * @param descriptor the descriptor of the dependency to resolve</span><br><span class="line">	 * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm</span><br><span class="line">	 * @return whether the bean should be considered as autowire candidate</span><br><span class="line">	 */</span><br><span class="line">	protected boolean isAutowireCandidate(String beanName, DependencyDescriptor descriptor, AutowireCandidateResolver resolver)</span><br><span class="line">			throws NoSuchBeanDefinitionException &#123;</span><br><span class="line"></span><br><span class="line">		String beanDefinitionName = BeanFactoryUtils.transformedBeanName(beanName);</span><br><span class="line">		if (containsBeanDefinition(beanDefinitionName)) &#123;</span><br><span class="line">			return isAutowireCandidate(beanName, getMergedLocalBeanDefinition(beanDefinitionName), descriptor, resolver);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (containsSingleton(beanName)) &#123;</span><br><span class="line">			return isAutowireCandidate(beanName, new RootBeanDefinition(getType(beanName)), descriptor, resolver);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BeanFactory parent = getParentBeanFactory();</span><br><span class="line">		if (parent instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">			// No bean definition found in this factory -&gt; delegate to parent.</span><br><span class="line">			return ((DefaultListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor, resolver);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (parent instanceof ConfigurableListableBeanFactory) &#123;</span><br><span class="line">			// If no DefaultListableBeanFactory, can&apos;t pass the resolver along.</span><br><span class="line">			return ((ConfigurableListableBeanFactory) parent).isAutowireCandidate(beanName, descriptor);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Determine whether the specified bean definition qualifies as an autowire candidate,</span><br><span class="line">	 * to be injected into other beans which declare a dependency of matching type.</span><br><span class="line">	 * @param beanName the name of the bean definition to check</span><br><span class="line">	 * @param mbd the merged bean definition to check</span><br><span class="line">	 * @param descriptor the descriptor of the dependency to resolve</span><br><span class="line">	 * @param resolver the AutowireCandidateResolver to use for the actual resolution algorithm</span><br><span class="line">	 * @return whether the bean should be considered as autowire candidate</span><br><span class="line">	 */</span><br><span class="line">	protected boolean isAutowireCandidate(String beanName, RootBeanDefinition mbd,</span><br><span class="line">			DependencyDescriptor descriptor, AutowireCandidateResolver resolver) &#123;</span><br><span class="line"></span><br><span class="line">		String beanDefinitionName = BeanFactoryUtils.transformedBeanName(beanName);</span><br><span class="line">		resolveBeanClass(mbd, beanDefinitionName);</span><br><span class="line">		if (mbd.isFactoryMethodUnique &amp;&amp; mbd.factoryMethodToIntrospect == null) &#123;</span><br><span class="line">			new ConstructorResolver(this).resolveFactoryMethodIfPossible(mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		return resolver.isAutowireCandidate(</span><br><span class="line">				new BeanDefinitionHolder(mbd, beanName, getAliases(beanDefinitionName)), descriptor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">		BeanDefinition bd = this.beanDefinitionMap.get(beanName);</span><br><span class="line">		if (bd == null) &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;No bean named &apos;&quot; + beanName + &quot;&apos; found in &quot; + this);</span><br><span class="line">			&#125;</span><br><span class="line">			throw new NoSuchBeanDefinitionException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		return bd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Iterator&lt;String&gt; getBeanNamesIterator() &#123;</span><br><span class="line">		CompositeIterator&lt;String&gt; iterator = new CompositeIterator&lt;&gt;();</span><br><span class="line">		iterator.add(this.beanDefinitionNames.iterator());</span><br><span class="line">		iterator.add(this.manualSingletonNames.iterator());</span><br><span class="line">		return iterator;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void clearMetadataCache() &#123;</span><br><span class="line">		super.clearMetadataCache();</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void freezeConfiguration() &#123;</span><br><span class="line">		this.configurationFrozen = true;</span><br><span class="line">		this.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean isConfigurationFrozen() &#123;</span><br><span class="line">		return this.configurationFrozen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Considers all beans as eligible for metadata caching</span><br><span class="line">	 * if the factory&apos;s configuration has been marked as frozen.</span><br><span class="line">	 * @see #freezeConfiguration()</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected boolean isBeanEligibleForMetadataCaching(String beanName) &#123;</span><br><span class="line">		return (this.configurationFrozen || super.isBeanEligibleForMetadataCaching(beanName));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line">		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line">		List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">		// Trigger initialization of all non-lazy singleton beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				if (isFactoryBean(beanName)) &#123;</span><br><span class="line">					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">					if (bean instanceof FactoryBean) &#123;</span><br><span class="line">						final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">						boolean isEagerInit;</span><br><span class="line">						if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">							isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">											((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">									getAccessControlContext());</span><br><span class="line">						&#125;</span><br><span class="line">						else &#123;</span><br><span class="line">							isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">									((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">						&#125;</span><br><span class="line">						if (isEagerInit) &#123;</span><br><span class="line">							getBean(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Trigger post-initialization callback for all applicable beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			Object singletonInstance = getSingleton(beanName);</span><br><span class="line">			if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">				final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">				if (System.getSecurityManager() != null) &#123;</span><br><span class="line">					AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">						smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">						return null;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//---------------------------------------------------------------------</span><br><span class="line">	// Implementation of BeanDefinitionRegistry interface</span><br><span class="line">	//---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">			throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">		Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">		Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line"></span><br><span class="line">		if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">						&quot;Validation of bean definition failed&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line">		if (existingDefinition != null) &#123;</span><br><span class="line">			if (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">				throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">				// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Overriding user-defined bean definition for bean &apos;&quot; + beanName +</span><br><span class="line">							&quot;&apos; with a framework-generated bean definition: replacing [&quot; +</span><br><span class="line">							existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;Overriding bean definition for bean &apos;&quot; + beanName +</span><br><span class="line">							&quot;&apos; with a different definition: replacing [&quot; + existingDefinition +</span><br><span class="line">							&quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				if (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(&quot;Overriding bean definition for bean &apos;&quot; + beanName +</span><br><span class="line">							&quot;&apos; with an equivalent definition: replacing [&quot; + existingDefinition +</span><br><span class="line">							&quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (hasBeanCreationStarted()) &#123;</span><br><span class="line">				// Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">				synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">					this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">					List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">					updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">					updatedDefinitions.add(beanName);</span><br><span class="line">					this.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">					removeManualSingletonName(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// Still in startup registration phase</span><br><span class="line">				this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				this.beanDefinitionNames.add(beanName);</span><br><span class="line">				removeManualSingletonName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			this.frozenBeanDefinitionNames = null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (existingDefinition != null || containsSingleton(beanName)) &#123;</span><br><span class="line">			resetBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException &#123;</span><br><span class="line">		Assert.hasText(beanName, &quot;&apos;beanName&apos; must not be empty&quot;);</span><br><span class="line"></span><br><span class="line">		BeanDefinition bd = this.beanDefinitionMap.remove(beanName);</span><br><span class="line">		if (bd == null) &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;No bean named &apos;&quot; + beanName + &quot;&apos; found in &quot; + this);</span><br><span class="line">			&#125;</span><br><span class="line">			throw new NoSuchBeanDefinitionException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (hasBeanCreationStarted()) &#123;</span><br><span class="line">			// Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">			synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.remove(beanName);</span><br><span class="line">				this.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// Still in startup registration phase</span><br><span class="line">			this.beanDefinitionNames.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		this.frozenBeanDefinitionNames = null;</span><br><span class="line"></span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Reset all bean definition caches for the given bean,</span><br><span class="line">	 * including the caches of beans that are derived from it.</span><br><span class="line">	 * &lt;p&gt;Called after an existing bean definition has been replaced or removed,</span><br><span class="line">	 * triggering &#123;@link #clearMergedBeanDefinition&#125;, &#123;@link #destroySingleton&#125;</span><br><span class="line">	 * and &#123;@link MergedBeanDefinitionPostProcessor#resetBeanDefinition&#125; on the</span><br><span class="line">	 * given bean and on all bean definitions that have the given bean as parent.</span><br><span class="line">	 * @param beanName the name of the bean to reset</span><br><span class="line">	 * @see #registerBeanDefinition</span><br><span class="line">	 * @see #removeBeanDefinition</span><br><span class="line">	 */</span><br><span class="line">	protected void resetBeanDefinition(String beanName) &#123;</span><br><span class="line">		// Remove the merged bean definition for the given bean, if already created.</span><br><span class="line">		clearMergedBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">		// Remove corresponding bean from singleton cache, if any. Shouldn&apos;t usually</span><br><span class="line">		// be necessary, rather just meant for overriding a context&apos;s default beans</span><br><span class="line">		// (e.g. the default StaticMessageSource in a StaticApplicationContext).</span><br><span class="line">		destroySingleton(beanName);</span><br><span class="line"></span><br><span class="line">		// Notify all post-processors that the specified bean definition has been reset.</span><br><span class="line">		for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">			if (processor instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				((MergedBeanDefinitionPostProcessor) processor).resetBeanDefinition(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Reset all bean definitions that have the given bean as parent (recursively).</span><br><span class="line">		for (String bdName : this.beanDefinitionNames) &#123;</span><br><span class="line">			if (!beanName.equals(bdName)) &#123;</span><br><span class="line">				BeanDefinition bd = this.beanDefinitionMap.get(bdName);</span><br><span class="line">				if (beanName.equals(bd.getParentName())) &#123;</span><br><span class="line">					resetBeanDefinition(bdName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Only allows alias overriding if bean definition overriding is allowed.</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected boolean allowAliasOverriding() &#123;</span><br><span class="line">		return isAllowBeanDefinitionOverriding();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void registerSingleton(String beanName, Object singletonObject) throws IllegalStateException &#123;</span><br><span class="line">		super.registerSingleton(beanName, singletonObject);</span><br><span class="line">		updateManualSingletonNames(set -&gt; set.add(beanName), set -&gt; !this.beanDefinitionMap.containsKey(beanName));</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void destroySingletons() &#123;</span><br><span class="line">		super.destroySingletons();</span><br><span class="line">		updateManualSingletonNames(Set::clear, set -&gt; !set.isEmpty());</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void destroySingleton(String beanName) &#123;</span><br><span class="line">		super.destroySingleton(beanName);</span><br><span class="line">		removeManualSingletonName(beanName);</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void removeManualSingletonName(String beanName) &#123;</span><br><span class="line">		updateManualSingletonNames(set -&gt; set.remove(beanName), set -&gt; set.contains(beanName));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Update the factory&apos;s internal set of manual singleton names.</span><br><span class="line">	 * @param action the modification action</span><br><span class="line">	 * @param condition a precondition for the modification action</span><br><span class="line">	 * (if this condition does not apply, the action can be skipped)</span><br><span class="line">	 */</span><br><span class="line">	private void updateManualSingletonNames(Consumer&lt;Set&lt;String&gt;&gt; action, Predicate&lt;Set&lt;String&gt;&gt; condition) &#123;</span><br><span class="line">		//省略</span><br><span class="line">        ....</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Remove any assumptions about by-type mappings.</span><br><span class="line">	 */</span><br><span class="line">	private void clearByTypeCache() &#123;</span><br><span class="line">		this.allBeanNamesByType.clear();</span><br><span class="line">		this.singletonBeanNamesByType.clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//---------------------------------------------------------------------</span><br><span class="line">	// Dependency resolution functionality</span><br><span class="line">	//---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(Class&lt;T&gt; requiredType) throws BeansException &#123;</span><br><span class="line">		/省略</span><br><span class="line">        ....</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	@Nullable</span><br><span class="line">	private &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(</span><br><span class="line">			ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) throws BeansException &#123;</span><br><span class="line">        //省略</span><br><span class="line">		....</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		StringBuilder sb = new StringBuilder(ObjectUtils.identityToString(this));</span><br><span class="line">		sb.append(&quot;: defining beans [&quot;);</span><br><span class="line">		sb.append(StringUtils.collectionToCommaDelimitedString(this.beanDefinitionNames));</span><br><span class="line">		sb.append(&quot;]; &quot;);</span><br><span class="line">		BeanFactory parent = getParentBeanFactory();</span><br><span class="line">		if (parent == null) &#123;</span><br><span class="line">			sb.append(&quot;root of factory hierarchy&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			sb.append(&quot;parent: &quot;).append(ObjectUtils.identityToString(parent));</span><br><span class="line">		&#125;</span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，DefaultListableBeanFactory内部维护了几个map来保存信息，其中beanDefinition就是从xml文件中读取出来的信息的封装，下面是beandefinition源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Copyright 2002-2019 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      https://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">package org.springframework.beans.factory.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeanMetadataElement;</span><br><span class="line">import org.springframework.beans.MutablePropertyValues;</span><br><span class="line">import org.springframework.core.AttributeAccessor;</span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * A BeanDefinition describes a bean instance, which has property values,</span><br><span class="line"> * constructor argument values, and further information supplied by</span><br><span class="line"> * concrete implementations.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is just a minimal interface: The main intention is to allow a</span><br><span class="line"> * &#123;@link BeanFactoryPostProcessor&#125; to introspect and modify property values</span><br><span class="line"> * and other bean metadata.</span><br><span class="line"> *</span><br><span class="line"> * @author Juergen Hoeller</span><br><span class="line"> * @author Rob Harrop</span><br><span class="line"> * @since 19.03.2004</span><br><span class="line"> * @see ConfigurableListableBeanFactory#getBeanDefinition</span><br><span class="line"> * @see org.springframework.beans.factory.support.RootBeanDefinition</span><br><span class="line"> * @see org.springframework.beans.factory.support.ChildBeanDefinition</span><br><span class="line"> */</span><br><span class="line">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Scope identifier for the standard singleton scope: &quot;singleton&quot;.</span><br><span class="line">	 * &lt;p&gt;Note that extended bean factories might support further scopes.</span><br><span class="line">	 * @see #setScope</span><br><span class="line">	 */</span><br><span class="line">	String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Scope identifier for the standard prototype scope: &quot;prototype&quot;.</span><br><span class="line">	 * &lt;p&gt;Note that extended bean factories might support further scopes.</span><br><span class="line">	 * @see #setScope</span><br><span class="line">	 */</span><br><span class="line">	String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Role hint indicating that a &#123;@code BeanDefinition&#125; is a major part</span><br><span class="line">	 * of the application. Typically corresponds to a user-defined bean.</span><br><span class="line">	 */</span><br><span class="line">	int ROLE_APPLICATION = 0;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Role hint indicating that a &#123;@code BeanDefinition&#125; is a supporting</span><br><span class="line">	 * part of some larger configuration, typically an outer</span><br><span class="line">	 * &#123;@link org.springframework.beans.factory.parsing.ComponentDefinition&#125;.</span><br><span class="line">	 * &#123;@code SUPPORT&#125; beans are considered important enough to be aware</span><br><span class="line">	 * of when looking more closely at a particular</span><br><span class="line">	 * &#123;@link org.springframework.beans.factory.parsing.ComponentDefinition&#125;,</span><br><span class="line">	 * but not when looking at the overall configuration of an application.</span><br><span class="line">	 */</span><br><span class="line">	int ROLE_SUPPORT = 1;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Role hint indicating that a &#123;@code BeanDefinition&#125; is providing an</span><br><span class="line">	 * entirely background role and has no relevance to the end-user. This hint is</span><br><span class="line">	 * used when registering beans that are completely part of the internal workings</span><br><span class="line">	 * of a &#123;@link org.springframework.beans.factory.parsing.ComponentDefinition&#125;.</span><br><span class="line">	 */</span><br><span class="line">	int ROLE_INFRASTRUCTURE = 2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// Modifiable attributes</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the name of the parent definition of this bean definition, if any.</span><br><span class="line">	 */</span><br><span class="line">	void setParentName(@Nullable String parentName);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the name of the parent definition of this bean definition, if any.</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	String getParentName();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Specify the bean class name of this bean definition.</span><br><span class="line">	 * &lt;p&gt;The class name can be modified during bean factory post-processing,</span><br><span class="line">	 * typically replacing the original class name with a parsed variant of it.</span><br><span class="line">	 * @see #setParentName</span><br><span class="line">	 * @see #setFactoryBeanName</span><br><span class="line">	 * @see #setFactoryMethodName</span><br><span class="line">	 */</span><br><span class="line">	void setBeanClassName(@Nullable String beanClassName);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the current bean class name of this bean definition.</span><br><span class="line">	 * &lt;p&gt;Note that this does not have to be the actual class name used at runtime, in</span><br><span class="line">	 * case of a child definition overriding/inheriting the class name from its parent.</span><br><span class="line">	 * Also, this may just be the class that a factory method is called on, or it may</span><br><span class="line">	 * even be empty in case of a factory bean reference that a method is called on.</span><br><span class="line">	 * Hence, do &lt;i&gt;not&lt;/i&gt; consider this to be the definitive bean type at runtime but</span><br><span class="line">	 * rather only use it for parsing purposes at the individual bean definition level.</span><br><span class="line">	 * @see #getParentName()</span><br><span class="line">	 * @see #getFactoryBeanName()</span><br><span class="line">	 * @see #getFactoryMethodName()</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	String getBeanClassName();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Override the target scope of this bean, specifying a new scope name.</span><br><span class="line">	 * @see #SCOPE_SINGLETON</span><br><span class="line">	 * @see #SCOPE_PROTOTYPE</span><br><span class="line">	 */</span><br><span class="line">	void setScope(@Nullable String scope);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the name of the current target scope for this bean,</span><br><span class="line">	 * or &#123;@code null&#125; if not known yet.</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	String getScope();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set whether this bean should be lazily initialized.</span><br><span class="line">	 * &lt;p&gt;If &#123;@code false&#125;, the bean will get instantiated on startup by bean</span><br><span class="line">	 * factories that perform eager initialization of singletons.</span><br><span class="line">	 */</span><br><span class="line">	void setLazyInit(boolean lazyInit);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return whether this bean should be lazily initialized, i.e. not</span><br><span class="line">	 * eagerly instantiated on startup. Only applicable to a singleton bean.</span><br><span class="line">	 */</span><br><span class="line">	boolean isLazyInit();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the names of the beans that this bean depends on being initialized.</span><br><span class="line">	 * The bean factory will guarantee that these beans get initialized first.</span><br><span class="line">	 */</span><br><span class="line">	void setDependsOn(@Nullable String... dependsOn);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the bean names that this bean depends on.</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set whether this bean is a candidate for getting autowired into some other bean.</span><br><span class="line">	 * &lt;p&gt;Note that this flag is designed to only affect type-based autowiring.</span><br><span class="line">	 * It does not affect explicit references by name, which will get resolved even</span><br><span class="line">	 * if the specified bean is not marked as an autowire candidate. As a consequence,</span><br><span class="line">	 * autowiring by name will nevertheless inject a bean if the name matches.</span><br><span class="line">	 */</span><br><span class="line">	void setAutowireCandidate(boolean autowireCandidate);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return whether this bean is a candidate for getting autowired into some other bean.</span><br><span class="line">	 */</span><br><span class="line">	boolean isAutowireCandidate();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set whether this bean is a primary autowire candidate.</span><br><span class="line">	 * &lt;p&gt;If this value is &#123;@code true&#125; for exactly one bean among multiple</span><br><span class="line">	 * matching candidates, it will serve as a tie-breaker.</span><br><span class="line">	 */</span><br><span class="line">	void setPrimary(boolean primary);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return whether this bean is a primary autowire candidate.</span><br><span class="line">	 */</span><br><span class="line">	boolean isPrimary();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Specify the factory bean to use, if any.</span><br><span class="line">	 * This the name of the bean to call the specified factory method on.</span><br><span class="line">	 * @see #setFactoryMethodName</span><br><span class="line">	 */</span><br><span class="line">	void setFactoryBeanName(@Nullable String factoryBeanName);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the factory bean name, if any.</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	String getFactoryBeanName();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Specify a factory method, if any. This method will be invoked with</span><br><span class="line">	 * constructor arguments, or with no arguments if none are specified.</span><br><span class="line">	 * The method will be invoked on the specified factory bean, if any,</span><br><span class="line">	 * or otherwise as a static method on the local bean class.</span><br><span class="line">	 * @see #setFactoryBeanName</span><br><span class="line">	 * @see #setBeanClassName</span><br><span class="line">	 */</span><br><span class="line">	void setFactoryMethodName(@Nullable String factoryMethodName);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return a factory method, if any.</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	String getFactoryMethodName();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the constructor argument values for this bean.</span><br><span class="line">	 * &lt;p&gt;The returned instance can be modified during bean factory post-processing.</span><br><span class="line">	 * @return the ConstructorArgumentValues object (never &#123;@code null&#125;)</span><br><span class="line">	 */</span><br><span class="line">	ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return if there are constructor argument values defined for this bean.</span><br><span class="line">	 * @since 5.0.2</span><br><span class="line">	 */</span><br><span class="line">	default boolean hasConstructorArgumentValues() &#123;</span><br><span class="line">		return !getConstructorArgumentValues().isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the property values to be applied to a new instance of the bean.</span><br><span class="line">	 * &lt;p&gt;The returned instance can be modified during bean factory post-processing.</span><br><span class="line">	 * @return the MutablePropertyValues object (never &#123;@code null&#125;)</span><br><span class="line">	 */</span><br><span class="line">	MutablePropertyValues getPropertyValues();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return if there are property values values defined for this bean.</span><br><span class="line">	 * @since 5.0.2</span><br><span class="line">	 */</span><br><span class="line">	default boolean hasPropertyValues() &#123;</span><br><span class="line">		return !getPropertyValues().isEmpty();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the name of the initializer method.</span><br><span class="line">	 * @since 5.1</span><br><span class="line">	 */</span><br><span class="line">	void setInitMethodName(@Nullable String initMethodName);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the name of the initializer method.</span><br><span class="line">	 * @since 5.1</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	String getInitMethodName();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the name of the destroy method.</span><br><span class="line">	 * @since 5.1</span><br><span class="line">	 */</span><br><span class="line">	void setDestroyMethodName(@Nullable String destroyMethodName);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the name of the destroy method.</span><br><span class="line">	 * @since 5.1</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	String getDestroyMethodName();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set the role hint for this &#123;@code BeanDefinition&#125;. The role hint</span><br><span class="line">	 * provides the frameworks as well as tools with an indication of</span><br><span class="line">	 * the role and importance of a particular &#123;@code BeanDefinition&#125;.</span><br><span class="line">	 * @since 5.1</span><br><span class="line">	 * @see #ROLE_APPLICATION</span><br><span class="line">	 * @see #ROLE_SUPPORT</span><br><span class="line">	 * @see #ROLE_INFRASTRUCTURE</span><br><span class="line">	 */</span><br><span class="line">	void setRole(int role);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Get the role hint for this &#123;@code BeanDefinition&#125;. The role hint</span><br><span class="line">	 * provides the frameworks as well as tools with an indication of</span><br><span class="line">	 * the role and importance of a particular &#123;@code BeanDefinition&#125;.</span><br><span class="line">	 * @see #ROLE_APPLICATION</span><br><span class="line">	 * @see #ROLE_SUPPORT</span><br><span class="line">	 * @see #ROLE_INFRASTRUCTURE</span><br><span class="line">	 */</span><br><span class="line">	int getRole();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Set a human-readable description of this bean definition.</span><br><span class="line">	 * @since 5.1</span><br><span class="line">	 */</span><br><span class="line">	void setDescription(@Nullable String description);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return a human-readable description of this bean definition.</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	String getDescription();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// Read-only attributes</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return whether this a &lt;b&gt;Singleton&lt;/b&gt;, with a single, shared instance</span><br><span class="line">	 * returned on all calls.</span><br><span class="line">	 * @see #SCOPE_SINGLETON</span><br><span class="line">	 */</span><br><span class="line">	boolean isSingleton();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return whether this a &lt;b&gt;Prototype&lt;/b&gt;, with an independent instance</span><br><span class="line">	 * returned for each call.</span><br><span class="line">	 * @since 3.0</span><br><span class="line">	 * @see #SCOPE_PROTOTYPE</span><br><span class="line">	 */</span><br><span class="line">	boolean isPrototype();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return whether this bean is &quot;abstract&quot;, that is, not meant to be instantiated.</span><br><span class="line">	 */</span><br><span class="line">	boolean isAbstract();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return a description of the resource that this bean definition</span><br><span class="line">	 * came from (for the purpose of showing context in case of errors).</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	String getResourceDescription();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the originating BeanDefinition, or &#123;@code null&#125; if none.</span><br><span class="line">	 * Allows for retrieving the decorated bean definition, if any.</span><br><span class="line">	 * &lt;p&gt;Note that this method returns the immediate originator. Iterate through the</span><br><span class="line">	 * originator chain to find the original BeanDefinition as defined by the user.</span><br><span class="line">	 */</span><br><span class="line">	@Nullable</span><br><span class="line">	BeanDefinition getOriginatingBeanDefinition();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinition中封装了所有bean需要的属性，然后存储在DefaultListableBeanFactory中，然后着个factory还继承了其他的许多接口和类，看下他们的作用：<br><img src="https://github.com/qingqian7/images/blob/master/spring_afterread/1.png?raw=true" alt="image"></p>
<ul>
<li>AliasRegistry 定义对别名的增删查改操作</li>
<li>SingletonBeanRegistry 定义对单例的注册以及获取</li>
<li>BeanFactory 定义获取bean以及bean的各种属性</li>
<li>BeanDefinitionRegistry 定义对beanDefinition的各种增删查改</li>
<li>ConfigurableBeanFactory 提供配置factory的各种方法</li>
<li>AbstractBeanFactory 综合FactoryBeanRegistrySupport和ConfigurableBeanFactory的功能</li>
<li>AutowireCapableBeanFactory 提供创建bean，自动注入，初始化以及应用bean的后处理器</li>
<li>ConfigurableListableBeanFactory beanFactory的配置清单，指定忽略的类型以及接口<br>有了这些，就可以方便对DefaultListableBeanFactory中的属性进行操作</li>
</ul>
<h3 id="XmlBeanFactory"><a href="#XmlBeanFactory" class="headerlink" title="XmlBeanFactory"></a>XmlBeanFactory</h3><p>上面说过，XmlBeanFactory与defaultlistablebeanfactory的不同在于多了对于xml的读取功能，这是通过xmlbeandefinitoinreader这个类来实现的，其读取过程中各个类的功能以及调用顺序如下：</p>
<ul>
<li>ResourceLoader 定义资源加载器，主要用于根据给定的资源文件地址返回对应的resource(spring将xml文件读取出来后抽象成resource)</li>
<li>BeanDifinitionReader 主要定义资源文件读取并转换为beanDefinition的各个功能</li>
<li>EnvironmentCapable 定义获取Environment的方法（获取环境属性是指获取通过别的文件中配置的属性，用来给el表达式赋值这种）</li>
<li>DocumentLoader 定义从资源文件加载转换为document的方法</li>
<li>BeanDefinitionDocumentReader 定义读取Document并注册beandefinition功能</li>
<li>BeanDefinitionParserDelegate 定义解析Element的方法<br>大致流程为：<br>(1)通过继承自AbstractBeanDefinitionReader中的方法，来使用ResourceLoader将资源文件转换为对应的Resource文件<br>(2)通过DocumentLoader对Resource文件进行转换，将Resource文件转换为Document文件<br>(3)通过实现接口BeanDefinitionDocumentReader的DefaultBeanDefinitionDocumentReader类对Document进行解析，并使用BeanDefinitionParserDelegate对Element进行解析，然后封装成BeanDefinition</li>
</ul>
<h3 id="bean的加载"><a href="#bean的加载" class="headerlink" title="bean的加载"></a>bean的加载</h3><p>前面大致说明的bean的解析过程和注册过程，这里接着讲bean的加载以及实例化。对于bean的加载功能，spring中调用方式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyBean bean = (MyBean)beanfactory.getBean(&quot;myTestBean&quot;);</span><br></pre></td></tr></table></figure>

<p>要实现这一步骤，需要考虑几个问题：<br>（1）spring中大多数实例是单例的，如何保证<br>（2）实例化时如何匹配构造函数有无参数<br>（3）实例化时如果有循环依赖怎么解决<br>下面来逐步分析：<br>单例在spring中的同一个容器内只会被实现一次，后续再获取就会在单例缓存中获取。首先了解一下这部分用于存储bean的不同map</p>
<ul>
<li>singletonObjects: 用于保存BeanName和创建bean实例之间的关系，beanName -&gt; beanInstance</li>
<li>singletonFactories: 用于保存BeanName和创建bean的工厂之间的关系，beanName -&gt; ObjectFactory</li>
<li>earlySingletonObjects: 也是用于保存beanName和beanInstance之间的关系，不同的是，当一个单例被放在这里后，那么当bean还在创建过程中，就可以通过getBean()方法获取到，其目的是用来检测循环引用（后面会讲解）</li>
<li>registeredSingletons: 用来保存当前已经注册的bean<br>获取单例时，会先尝试从singletonObjects中获取实例，如果获取不到，就从earlySingletonObhects中获取（获取到说明正在创建中），还获取不到，就从singletonFactories中获取beanName对应的ObjectFactory,然后用这个objectFactory的getObject()方法创建bean,并放到earlySingletonObjects中去（在创建），并且从singletonFactories中remove掉这个objectFactory</li>
</ul>
<p>从ObjectFactory中获取bean的时候，会有一些准备工作，包括一些辅助的状态存储和override等的处理，另外可以通过BeanPostProcessor来做一些实例化的前置处理和后置处理，后面在拓展部份会给出</p>
<h4 id="实例化时："><a href="#实例化时：" class="headerlink" title="实例化时："></a>实例化时：</h4><p>（1）如果在RootBeanDefinition中存在factoryMethodName属性或者在配置文件中存在factory-method属性，则spring尝试根据RootBeanDefinition中的配置（解析xml得到具体函数）生成bean的实例<br>（2）<strong>解析构造函数并进行构造函数的实例化。因为一个bean对应的构造函数可能有多个，每个构造函数的参数不同，spring会根据参数及类型去判断最终使用那个构造函数。<br>在实例化时，并不是简单的用反射来实例化。过程中，先调用beandefinition.getMethodOverrides()是否为空，为空则说明用户没有使用replace或者lookup的配置方法，那么就直接使用反射。但如果使用了这两个特性，就必须使用动态代理的方式将这两个特性所对应的逻辑的拦截增强其设置进去，这样才能保证在调用方法的时候会被相应的拦截器增强，返回的对象也是包含拦截器的代理实例</strong>。</p>
<p>这里说明循环依赖的问题。首先定义循环引用类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class TestA&#123;</span><br><span class="line">    private TestB testB;</span><br><span class="line">    public void setTestB(TestB testB)&#123;</span><br><span class="line">        this.testB = testB;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TestB&#123;</span><br><span class="line">    private TestA testA;</span><br><span class="line">    public void setTestA(TestA testA)&#123;</span><br><span class="line">        this.testA = testA;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环依赖也分为3中情况：</p>
<h4 id="（1）构造器循环依赖："><a href="#（1）构造器循环依赖：" class="headerlink" title="（1）构造器循环依赖："></a>（1）构造器循环依赖：</h4><p>表示通过构造器（构造函数）注入构成的循环依赖，此依赖是没有办法解决的，只能抛出BeanCurrentlyCreationException异常</p>
<ul>
<li>spring在创建testA时，发现A没有在创建，就将A放入“当前创建池”中，然后因为需要TestB,则去创建B</li>
<li>发现B没有在创建（不在池中），就去创建B.</li>
<li>创建B时，需要创建A,就去创建A,却发现A在创建池中，因此表示循环依赖，抛出异常<h4 id="（2）setter循环依赖"><a href="#（2）setter循环依赖" class="headerlink" title="（2）setter循环依赖"></a>（2）setter循环依赖</h4>表示通过setter注入的方式构成的循环依赖。对于setter构成的循环依赖是通过spring容器提前暴露刚完成构造器注入但是未完成其他步骤（如只用了默认无参构造器而没有调用setter）的bean来完成的，而且只能解决单例作用域的bean循环依赖。通过提前暴露一个单例工厂方法，从而使其他bean能引用到该bean<br>步骤如下：</li>
<li>spring创建单例testA,首先根据无参构造函数创建bean,并暴露一个“ObjectFactory”用于返回一个提前暴露一个创建中的bean，将testA标志放到“当前创建bean池中”，然后setter注入TestB</li>
<li>spring创建单例TestB,根据无参构造函数创建bean,并暴露一个“ObjectFactory”用于返回一个提前暴露一个创建中的bean，将testB标志放到“当前创建bean池中”，然后setter注入TestA</li>
<li>TestB注入TestA时，由于提前暴露了提前暴露了TestA的ObjectFactory工厂，从而使用它来返回提前暴露一个创建中的bean</li>
<li>TestA同理注入TestB<br>当然这里ObjectFactory返回的bean还是没有初始化的bean,但是由于后面的bean的填充的属性的引用是一样的，所以也可以通过这里的bean来获取到<br>####（3）prototype范围的依赖处理<br>对于prototype的作用于bean,spring容器无法完成依赖注入，因为spring容器不进行缓存prototype作用与的bean,因此无法提前暴露一个创建中的bean</li>
</ul>
<p>对于singleton作用域的bean，可以通过setAllowCircleREference(false)来禁止循环引用’<br>至此，bean的加载以及实例化流程也大致说明了。<br>再是属性注入了。属性注入的大致流程如下：<br>（1）首先判断有无InstantiationAwareBeanPostProcessors,此处理器的postProcessAfterInstantiation()函数的应用可以在属性设置前改变bean,也可以控制是否继续属性填充<br>（2）根据注入类型（byType/byType）,提取依赖的bean，并统一存入PropertyValue中<br>（3）应用InstantiationAwareBeanPostProcessor处理器的postProcessPropertyValues方法，对属性获取完毕填充前对属性的再次处理，<br>（4）将所有propertyvalue中的属性填充至BeanWrapper中<br>最后就是初始化bean了。初始化是调用通过配置中的init-method的属性来根据用户业务进行相应的实例化。初始化主要是针对基本类型的属性的赋值。如果没有配置，则就不需要进行属性初始化。</p>
<h3 id="spring拓展"><a href="#spring拓展" class="headerlink" title="spring拓展"></a>spring拓展</h3><p>Spring中还提供了另一个接口ApplicationContext，用于扩展BeanFactory中现有的功能。ApplicationContext和BeanFactory两者都是用于加载Bean的，但是相比之下，ApplicationContext提供了更多的扩展功能，ApplicationContext包含了BeanFactory的所有功能。绝大多数典型的企业应用和系统，ApplicationContext就是你需要使用的。<br>首先看看使用这两个不同的类去加载配置文件在写法上的不同。<br>使用BeanFactory方式加载XML<br>   BeanFactory bf = new XmlBeanFactory(new ClassPathResource(“beanFactoryTest.xml”));<br>使用ApplicationContext方式加载XML<br>   ApplicationContext bf = new ClassPathXmlApplicationContext(“beanFactoryTest.xml”));<br> 设置了路径后，便可以根据路径做配置文件的解析以及各种功能的实现了。可以说refresh函数中包含了几乎ApplicationContext中提供的全部功能，而且此函数中逻辑非常清晰明了，使我们很容易分析对应的层次及逻辑。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">        synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">            // Prepare this context for refreshing.</span><br><span class="line">            //准备刷新的上下文环境</span><br><span class="line">            prepareRefresh();</span><br><span class="line"></span><br><span class="line">            // Tell the subclass to refresh the internal bean factory.</span><br><span class="line">            //初始化BeanFactory，并进行XML文件读取</span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">            // Prepare the bean factory for use in this context.</span><br><span class="line">            //对BeanFactory进行各种功能填充</span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                // Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">                //子类覆盖方法做额外的处理</span><br><span class="line">                postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">                // Invoke factory processors registered as beans in the context.</span><br><span class="line">                //激活各种BeanFactory处理器</span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">                // Register bean processors that intercept bean creation.</span><br><span class="line">                //注册拦截Bean创建的Bean处理器，这里只是注册，真正的调用是在getBean时候</span><br><span class="line">                registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">                // Initialize message source for this context.</span><br><span class="line">                //为上下文初始化Message源，即不同语言的消息体，国际化处理</span><br><span class="line">                initMessageSource();</span><br><span class="line"></span><br><span class="line">                // Initialize event multicaster for this context.</span><br><span class="line">                //初始化应用消息广播器，并放入&quot;applicationEventMulticaster&quot; bean中</span><br><span class="line">                initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">                // Initialize other special beans in specific context subclasses.</span><br><span class="line">                //留给子类来初始化其它的Bean</span><br><span class="line">                onRefresh();</span><br><span class="line"></span><br><span class="line">                // Check for listener beans and register them.</span><br><span class="line">                //在所有注册的bean中查找Listener bean，注册到消息广播中</span><br><span class="line">                registerListeners();</span><br><span class="line"></span><br><span class="line">                // Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">                //初始化剩下的单实例（非惰性的）</span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">                // Last step: publish corresponding event.</span><br><span class="line">                //完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人</span><br><span class="line">                finishRefresh();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            catch (BeansException ex) &#123;</span><br><span class="line">                if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">                            &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">                destroyBeans();</span><br><span class="line"></span><br><span class="line">                // Reset &apos;active&apos; flag.</span><br><span class="line">                cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">                // Propagate exception to caller.</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            finally &#123;</span><br><span class="line">                // Reset common introspection caches in Spring&apos;s core, since we</span><br><span class="line">                // might not ever need metadata for singleton beans anymore...</span><br><span class="line">                resetCommonCaches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面概况一下ClassPathXmlApplicationContext初始化的步骤，并从中解析一下它为我们提供的功能。</p>
<p>  （1）初始化前的准备工作，例如对系统属性或者环境变量进行准备及验证。<br>      在某种情况下项目的使用需要读取某些系统变量，二这个变量的设置很可能会影响系统的正确性，那么ClassPathXmlApplicationContext为我们提供的这个准备函数就显得非常必要，它可以在Spring启动的时候提前对必须的变量进行存在性验证。<br>  （2）初始化BeanFactory，并进行XML文件读取。<br>  之前有提到ClassPathXmlApplicationContext包含着BeanFactory所提供的一切特征，那么这一步骤中将会复用BeanFactory中的配置文件读取解析及其它功能，这一步之后，ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能，也就是可以进行Bean的提取等基础操作了。<br>  （3）对BeanFactory进行各种功能填充。<br>    是否允许bean覆盖，是否允许循环依赖等。<br>  （4）子类覆盖方法做额外的处理<br>  Spring之所以强大，为世人所推崇，除了它功能上为大家提供了便利外，还有一方面是它的完美架构，开放式的架构让使用它的程序员很容易根据业务需要扩展已经存在的功能。这种开放式的设计在Spring中随处可见，例如在本例中就提供了一个空的函数实现postProcessBeanFactory来方便程序员在业务上做进一步的扩展。<br>  （5）激活各种BeanFactory处理器<br>  （6）注册拦截bean创建的bean处理器，这里只是注册，真正的调用是在getBean时候。<br>  （7）为上下文初始化Message源，即对不同语言的消息体进行国际化处理。<br>  （8）初始化应用消息广播器，并放入“applicationEventMulticaster” bean中。<br>  （9）留给子类来初始化其它的bean。<br>  （10）在所有注册的bean中查找listener bean，注册到消息广播器中。<br>  （11）初始化剩下的单实例（非惰性的）.<br>  （12）完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人。<br>然后spring拓展主要是在第6步，注册各种处理器来进行功能扩展<br>这里看下最常见的BeanPostProcessor这个拓展接口，它使得我门在创建bean实例的前后可以做一些自己的处理<br><img src="https://github.com/qingqian7/images/blob/master/spring_afterread/2.png?raw=true" alt="image"><br>看下BeanPostProcessor接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line">    //在初始化之前调用</span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line">    //在初始化之后调用</span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果这个接口的某个实现类被注册到某个容器，那么该容器的每个Bean在调用初始化方法之前，都会获得该接口实现类的一个回调。容器调用接口定义的方法时会将该受管Bean的实例和名字通过参数传入方法，进过处理后通过方法的返回值返回给容器。也就是回调了postProcessBeforeInitialization 方法</p>
<p> 要使用BeanPostProcessor回调，就必须先在容器中注册实现该接口的类，那么如何注册呢？BeanFactory和ApplicationContext容器的注册方式不大一样：若使用BeanFactory，则必须要显示的调用其addBeanPostProcessor()方法进行注册，参数为BeanPostProcessor实现类的实例；如果是使用ApplicationContext，那么容器会在配置文件在中自动寻找实现了BeanPostProcessor接口的Bean，然后自动注册，我们要做的只是配置一个BeanPostProcessor实现类的Bean就可以了。</p>
<p> 假如我们使用了多个的BeanPostProcessor的实现类，那么如何确定处理顺序呢？其实只要实现Ordered接口，设置order属性就可以很轻松的确定不同实现类的处理顺序了;<br> 接口中的两个方法都要将传入的bean返回，而不能返回null，如果返回的是null那么我们通过getBean方法将得不到目标</p>
<p> 根据上面的描述我们可以详细说下其中的两个问题</p>
<h4 id="ApplicationContext容器是怎样注册BeanPostProcessor的？"><a href="#ApplicationContext容器是怎样注册BeanPostProcessor的？" class="headerlink" title="ApplicationContext容器是怎样注册BeanPostProcessor的？"></a>ApplicationContext容器是怎样注册BeanPostProcessor的？</h4><p>AbstractApplicationContext中的refresh方法中有一个registerBeanPostProcessors方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">    //省略....</span><br><span class="line">        // Register bean processors that intercept bean creation.</span><br><span class="line">        registerBeanPostProcessors(beanFactory);</span><br><span class="line">    //省略....</span><br><span class="line">        /**</span><br><span class="line">        * 1.实例化剩余的所有非延迟加载单例对象</span><br><span class="line">        * 2.为什么说是剩余的？因为在上面的registerBeanPostProcessors中已经把所有BeanPostProcessors所有对象都已经实例化过了;</span><br><span class="line">        * 3.这加载的时候会判断bean是不是 FactoryBean类型的</span><br><span class="line">        *   3.1如果是FactoryBean类型，则getBean(&amp;beanName),这里是把FactoryBean本身的对象给实例化了，而没有调它的getObject方法；</span><br><span class="line">        *      3.1.1 还要判断是不是SmartFactoryBean类型的，SmartFactoryBean继承了FactoryBean接口；但是它多了一个    boolean isEagerInit();方法；这个方法就是判断是否需要通过FactoryBean的getObject()生成实例；</span><br><span class="line">        *   3.2如果不是FactoryBean类型，直接getBean就行了；</span><br><span class="line">        * 其实我们在上一篇分享 FactoryBean的时候，有调用BeanPostProcessors的后置方法，但是很不理解这里为啥还要执行一次，因为讲道理在之前就应该执行过，TODO...看文章....</span><br><span class="line">        * 4.还要判断是不是SmartInitializingSingleton接口，这个接口有个afterSingletonsInstantiated方法；</span><br><span class="line">        * 循环所以bean判断是不是这个类型的，只要是这个类型就调用afterSingletonsInstantiated方法；</span><br><span class="line">        */</span><br><span class="line">        finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                //省略..</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>代码入口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanPostProcessors(</span><br><span class="line">            ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line">        /**</span><br><span class="line">        *1.代码走到了这里的时候其实 BeanDefinition数据已经被加载了，只是bean还没有被实例化</span><br><span class="line">        所以这个是去容器里面找到所有类型为BeanPostProcessor的beanName</span><br><span class="line">        */</span><br><span class="line">        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">        //记录所有的beanProcessor数量，在这之前也可能注册了一部分Spring内部的BeanPostProcessors接口，例如：ApplicationContextAwareProcessor</span><br><span class="line">        int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">        //貌似只是记录日志用的</span><br><span class="line">        beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">        // 优先级最高的BeanPostProcessors，这类最先调用；需要实现PriorityOrdered接口</span><br><span class="line">        List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">        //内部BeanPostProcessors</span><br><span class="line">        List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">        //继承了Ordered接口，优先级币上面低一点</span><br><span class="line">        List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;String&gt;();</span><br><span class="line">        //这就是普通的了，优先级最低</span><br><span class="line">        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;String&gt;();</span><br><span class="line">        //下面的这些代码就是遍历所有postProcessorNames，按优先级排序；类型PriorityOrdered&gt;Ordered&gt;普通；在这个类型基础上，还要对他们的order属性就行排序；</span><br><span class="line">        for (String ppName : postProcessorNames) &#123;</span><br><span class="line">            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">                priorityOrderedPostProcessors.add(pp);</span><br><span class="line">                if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                    internalPostProcessors.add(pp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                orderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // First, register the BeanPostProcessors that implement PriorityOrdered.</span><br><span class="line">        sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">        registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">        // Next, register the BeanPostProcessors that implement Ordered.</span><br><span class="line">        List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">        for (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            orderedPostProcessors.add(pp);</span><br><span class="line">            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">        registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">        // Now, register all regular BeanPostProcessors.</span><br><span class="line">        List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">        for (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        //这里要注意一下了，看到没有，这个时候已经调用了getBean来生成实例对象了；</span><br><span class="line">            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            nonOrderedPostProcessors.add(pp);</span><br><span class="line">            if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">        // 排序</span><br><span class="line">        sortPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">        //注册</span><br><span class="line">        registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">        // 加入ApplicationListenerDetector</span><br><span class="line">        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注册 BeanPostProcessor beans.</span><br><span class="line">     * 容器中beanPostProcessors是一个ArrayList来持有这些BeanPostProcessors</span><br><span class="line">     */</span><br><span class="line">    private static void registerBeanPostProcessors(</span><br><span class="line">            ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors) &#123;</span><br><span class="line"></span><br><span class="line">        for (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">            beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">@Override</span><br><span class="line">    public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) &#123;</span><br><span class="line">        Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);</span><br><span class="line">        this.beanPostProcessors.remove(beanPostProcessor);</span><br><span class="line">        this.beanPostProcessors.add(beanPostProcessor);</span><br><span class="line">        //将是否 hasInstantiationAwareBeanPostProcessors设置为true </span><br><span class="line">        //关于InstantiationAwareBeanPostProcessor作用请看</span><br><span class="line">        //https://blog.csdn.net/u010634066/article/details/80321854</span><br><span class="line">        if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            this.hasInstantiationAwareBeanPostProcessors = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) &#123;</span><br><span class="line">            this.hasDestructionAwareBeanPostProcessors = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Spring加载完了所有的BeanDefinition之后，找到所有类型为BeanPostProcessors的BeanDefinition对象; </li>
<li>根据得到的类型是否实现了PriorityOrdered&gt;Ordered&gt;无继承Ordered；在这个优先级基础上，每个实现了Ordered接口的(PriorityOrdered也实现了Ordered)都有一个order属性，还要根据order来进行排序；例如有三个类<br>class PriorityOrderTest implements,BeanPostProcessor, PriorityOrdered<br>class OrderTest implements,BeanPostProcessor, Ordered<br>class NoneTest implements,BeanPostProcessor<br>然后PriorityOrderTest有两个实例<br>P1；p1.getOrder()=1<br>P2；p2.getOrder()=2<br>OrderTest 也有两个实例<br>O1；o1.getOrder()=3<br>O2；o2.getOrder()=4<br>None一个实例<br>n1:n1.getOrder()=100;<br>那么最终调用的顺序是 p2&gt;p1&gt;o2&gt;o1&gt;n1</li>
<li>把BeanPostProcessors注册到beanFactory的时候，注册是是BeanPostProcessors实例！,因为提前调用了getBean()方法得到了BeanPostProcessors实例; </li>
</ol>
<h4 id="什么时候调用BeanPostProcessors的方法呢？"><a href="#什么时候调用BeanPostProcessors的方法呢？" class="headerlink" title="什么时候调用BeanPostProcessors的方法呢？"></a>什么时候调用BeanPostProcessors的方法呢？</h4><p>调用的地方比较多，还有很多Spring内部的接口，还有其他的比如MergedBeanDefinitionPostProcessor等也继承了BeanPostProcessors接口的扩展接口，<br>我们这里先只分析我们自己继承这个BeanPostProcessors接口的实例是什么时候被调用的；<br>代码人口：<br>第一个调用的地方</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</span><br><span class="line">            throws BeanCreationException &#123;</span><br><span class="line">            //对依赖的对象属性进行注入</span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            if (exposedObject != null) &#123;</span><br><span class="line">            //BeanPostProcessors两个方法都在这里面</span><br><span class="line">                exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            //省略....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">    //省略....</span><br><span class="line">if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">    //初始化之前</span><br><span class="line">            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;//初始化</span><br><span class="line">            invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        //初始化之后</span><br><span class="line">if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    //省略...</span><br><span class="line"></span><br><span class="line">//注意 每一个实例对象触发这个的时候 都是执行所有的BeanPostProcessors实例对象</span><br><span class="line">@Override</span><br><span class="line">    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)</span><br><span class="line">            throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">        Object result = existingBean;</span><br><span class="line">        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        //这里是循环</span><br><span class="line">        //  result =BeanPostProcessor调用执行方法；返回的对象还是result，只是有可能被某个BeanPostProcessor加强了 beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">            if (result == null) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过这个代码可以清晰的知道调用时间；那我们重新理一下注册和使用 </p>
<ol>
<li>Spring识别BeanPostProcessors，通过提前getBean拿到实例，getBean也会触发接口的两个方法，但是这个时候当前BeanPostProcessors实例还没有被注册进去; </li>
<li>注册获取到的BeanPostProcessors实例; </li>
<li>后面只要有对象调用getBean就会触发BeanPostProcessors的方法；<br>不管是BeanPostProcessors.getBean()，还是finishBeanFactoryInitialization()注册剩余的实例都会触发；<h4 id="第二个调用的地方FactoryBeanRegistrySupport"><a href="#第二个调用的地方FactoryBeanRegistrySupport" class="headerlink" title="第二个调用的地方FactoryBeanRegistrySupport"></a>第二个调用的地方FactoryBeanRegistrySupport</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从FactoryBean中获取Bean</span><br><span class="line">     * @param factory the FactoryBean instance</span><br><span class="line">     * @param beanName the name of the bean</span><br><span class="line">     * @param shouldPostProcess whether the bean is subject to post-processing</span><br><span class="line">     * @return the object obtained from the FactoryBean</span><br><span class="line">     * @throws BeanCreationException if FactoryBean object creation failed</span><br><span class="line">     * @see org.springframework.beans.factory.FactoryBean#getObject()</span><br><span class="line">     */</span><br><span class="line">    protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) &#123;</span><br><span class="line">    //判断factory是单例的并且beanName已经被创建</span><br><span class="line">        if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">            synchronized (getSingletonMutex()) &#123;</span><br><span class="line">            //如果已经创建过直接返回</span><br><span class="line">                Object object = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                if (object == null) &#123;</span><br><span class="line">                    object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">                    // Only post-process and store if not put there already during getObject() call above</span><br><span class="line">                    // (e.g. because of circular reference processing triggered by custom getBean calls)</span><br><span class="line">                    //TODO....这里回头分析...</span><br><span class="line">                    Object alreadyThere = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                    if (alreadyThere != null) &#123;</span><br><span class="line">                        object = alreadyThere;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        if (object != null &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                            //执行所有后置处理器接口的方法BeanPostProcessor中的postProcessAfterInitialization(result, beanName);方法；</span><br><span class="line">                            //这里单独写一篇文章将后置处理器BeanPostProcessor</span><br><span class="line">                                object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                            catch (Throwable ex) &#123;</span><br><span class="line">                                throw new BeanCreationException(beanName,</span><br><span class="line">                                        &quot;Post-processing of FactoryBean&apos;s singleton object failed&quot;, ex);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">    //将通过factoryBean.getObject方法得到的对象存到 factoryBeanObjectCache中         this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return (object != NULL_OBJECT ? object : null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;//如果不是单例对象</span><br><span class="line">        //调用FactoryBean的getObject方法返回实例，也就是从水球里面取出水；</span><br><span class="line">            Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">            if (object != null &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                //执行后置处理器</span><br><span class="line">                    object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Throwable ex) &#123;</span><br><span class="line">                    throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean&apos;s object failed&quot;, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return object;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //调用FactoryBean的getObject放法</span><br><span class="line">    private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName)</span><br><span class="line">            throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">        Object object;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (System.getSecurityManager() != null) &#123;</span><br><span class="line">                AccessControlContext acc = getAccessControlContext();</span><br><span class="line">                try &#123;</span><br><span class="line">                    object = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public Object run() throws Exception &#123;</span><br><span class="line">                                return factory.getObject();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, acc);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                    throw pae.getException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                //可以看到最终调用了getObject方法；这是需要实现类自己实现</span><br><span class="line">                object = factory.getObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(beanName, &quot;FactoryBean threw exception on object creation&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Do not accept a null value for a FactoryBean that&apos;s not fully</span><br><span class="line">        // initialized yet: Many FactoryBeans just return null then.</span><br><span class="line">        if (object == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            throw new BeanCurrentlyInCreationException(</span><br><span class="line">                    beanName, &quot;FactoryBean which is currently in creation returned null from getObject&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>1.BeanPostProcessors注册发生在容器启动的时候;自动注册BeanPostProcessors类型；<br>2.只要调用getBean初始化对象都会触发BeanPostProcessors接口的两个方法,并且是所有BeanPostProcessors实例都会触发；<br>3.如果是FactoryBean类型，容器不会帮我们自动初始化它产生的实例<br>除非是SmartFactoryBean实例，并且它的isEagerInit()返回的是true;IOC容器才会也帮我们调用它的getObject方法来生成实例;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/10/spring-afterread/" data-id="cjydsg9ir0011z0nw4r14zd8k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/30/b-tree/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          b+tree
        
      </div>
    </a>
  
  
    <a href="/2019/04/18/zookeeperlock/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">zookeeperlock</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现/">悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现/" style="font-size: 10px;">悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/22/跳表/">跳表</a>
          </li>
        
          <li>
            <a href="/2019/07/18/integer/">integer</a>
          </li>
        
          <li>
            <a href="/2019/07/16/lock/">lock</a>
          </li>
        
          <li>
            <a href="/2019/07/16/lock_20190718_210149/">lock</a>
          </li>
        
          <li>
            <a href="/2019/06/22/redis-cluster/">redis-cluster</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>