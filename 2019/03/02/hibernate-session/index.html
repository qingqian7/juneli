<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>hibernate_session | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在本篇随笔里将会分析一下hibernate的缓存机制，包括一级缓存(session级别)、二级缓存(sessionFactory级别)以及查询缓存，当然还要讨论下我们的N+1的问题。 随笔虽长，但我相信看完的朋友绝对能对hibernate的 N+1问题以及缓存有更深的了解。">
<meta property="og:type" content="article">
<meta property="og:title" content="hibernate_session">
<meta property="og:url" content="http://yoursite.com/2019/03/02/hibernate-session/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="在本篇随笔里将会分析一下hibernate的缓存机制，包括一级缓存(session级别)、二级缓存(sessionFactory级别)以及查询缓存，当然还要讨论下我们的N+1的问题。 随笔虽长，但我相信看完的朋友绝对能对hibernate的 N+1问题以及缓存有更深的了解。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-18T13:02:51.637Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hibernate_session">
<meta name="twitter:description" content="在本篇随笔里将会分析一下hibernate的缓存机制，包括一级缓存(session级别)、二级缓存(sessionFactory级别)以及查询缓存，当然还要讨论下我们的N+1的问题。 随笔虽长，但我相信看完的朋友绝对能对hibernate的 N+1问题以及缓存有更深的了解。">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-hibernate-session" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/02/hibernate-session/" class="article-date">
  <time datetime="2019-03-02T12:34:26.000Z" itemprop="datePublished">2019-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      hibernate_session
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在本篇随笔里将会分析一下hibernate的缓存机制，包括一级缓存(session级别)、二级缓存(sessionFactory级别)以及查询缓存，当然还要讨论下我们的N+1的问题。</p>
<p>随笔虽长，但我相信看完的朋友绝对能对hibernate的 N+1问题以及缓存有更深的了解。</p>
<a id="more"></a>

<p>一、N+1问题</p>
<p>首先我们来探讨一下N+1的问题，我们先通过一个例子来看一下，什么是N+1问题：</p>
<p>list()获得对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">             * 此时会发出一条sql，将30个学生全部查询出来</span><br><span class="line">             */</span><br><span class="line">            List&lt;Student&gt; ls = (List&lt;Student&gt;)session.createQuery(&quot;from Student&quot;)</span><br><span class="line">                                .setFirstResult(0).setMaxResults(30).list();</span><br><span class="line">            Iterator&lt;Student&gt; stus = ls.iterator();</span><br><span class="line">            for(;stus.hasNext();)</span><br><span class="line">            &#123;</span><br><span class="line">                Student stu = (Student)stus.next();</span><br><span class="line">                System.out.println(stu.getName());</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>如果通过list()方法来获得对象，毫无疑问，hibernate会发出一条sql语句，将所有的对象查询出来，这点相信大家都能理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select student0_.id as id2_, student0_.name as name2_, student0_.rid as rid2_, student0_.sex as sex2_ from t_student student0_ limit ?</span><br></pre></td></tr></table></figure>

<p>那么，我们再来看看iterator()这种情况</p>
<p>iterator()获得对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">             * 如果使用iterator方法返回列表，对于hibernate而言，它仅仅只是发出取id列表的sql</span><br><span class="line">             * 在查询相应的具体的某个学生信息时，会发出相应的SQL去取学生信息</span><br><span class="line">             * 这就是典型的N+1问题</span><br><span class="line">             * 存在iterator的原因是，有可能会在一个session中查询两次数据，如果使用list每一次都会把所有的对象查询上来</span><br><span class="line">             * 而是要iterator仅仅只会查询id，此时所有的对象已经存储在一级缓存(session的缓存)中，可以直接获取</span><br><span class="line">             */</span><br><span class="line">            Iterator&lt;Student&gt; stus = (Iterator&lt;Student&gt;)session.createQuery(&quot;from Student&quot;)</span><br><span class="line">                                .setFirstResult(0).setMaxResults(30).iterate();</span><br><span class="line">            for(;stus.hasNext();)</span><br><span class="line">            &#123;</span><br><span class="line">                Student stu = (Student)stus.next();</span><br><span class="line">                System.out.println(stu.getName());</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>在执行完上述的测试用例后，我们来看看控制台的输出，看会发出多少条 sql 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select student0_.id as col_0_0_ from t_student student0_ limit ?</span><br><span class="line">Hibernate: select student0_.id as id2_0_, student0_.name as name2_0_, student0_.rid as rid2_0_, student0_.sex as sex2_0_ from t_student student0_ where student0_.id=?</span><br><span class="line">沈凡</span><br><span class="line">Hibernate: select student0_.id as id2_0_, student0_.name as name2_0_, student0_.rid as rid2_0_, student0_.sex as sex2_0_ from t_student student0_ where student0_.id=?</span><br><span class="line">王志名</span><br><span class="line">Hibernate: select student0_.id as id2_0_, student0_.name as name2_0_, student0_.rid as rid2_0_, student0_.sex as sex2_0_ from t_student student0_ where student0_.id=?</span><br><span class="line">叶敦</span><br><span class="line">.........</span><br></pre></td></tr></table></figure>

<p>我们看到，当如果通过iterator()方法来获得我们对象的时候，hibernate首先会发出1条sql去查询出所有对象的 id 值，当我们如果需要查询到某个对象的具体信息的时候，hibernate此时会根据查询出来的 id 值再发sql语句去从数据库中查询对象的信息，这就是典型的 N+1 的问题。</p>
<p>那么这种 N+1 问题我们如何解决呢，其实我们只需要使用 list() 方法来获得对象即可。但是既然可以通过 list() 我们就不会出现 N+1的问题，那么我们为什么还要保留 iterator()这种形式呢？我们考虑这样一种情况，如果我们需要在一个session当中要两次查询出很多对象，此时我们如果写两条 list()时，hibernate此时会发出两条 sql 语句，而且这两条语句是一样的，但是我们如果第一条语句使用 list()，而第二条语句使用 iterator()的话，此时我们也会发两条sql语句，但是第二条语句只会将查询出对象的id，所以相对应取出所有的对象而已，显然这样可以节省内存，而如果再要获取对象的时候，因为第一条语句已经将对象都查询出来了，此时会将对象保存到session的一级缓存中去，所以再次查询时，就会首先去缓存中查找，如果找到，则不发sql语句了。这里就牵涉到了接下来这个概念:hibernate的一级缓存。</p>
<p>二、一级缓存(session级别)</p>
<p>我们来看看hibernate提供的一级缓存： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">             * 此时会发出一条sql，将所有学生全部查询出来，并放到session的一级缓存当中</span><br><span class="line">             * 当再次查询学生信息时，会首先去缓存中看是否存在，如果不存在，再去数据库中查询</span><br><span class="line">             * 这就是hibernate的一级缓存(session缓存)</span><br><span class="line">             */</span><br><span class="line">            List&lt;Student&gt; stus = (List&lt;Student&gt;)session.createQuery(&quot;from Student&quot;)</span><br><span class="line">                                    .setFirstResult(0).setMaxResults(30).list();</span><br><span class="line">            Student stu = (Student)session.load(Student.class, 1);</span><br></pre></td></tr></table></figure>

<p>我们来看看控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select student0_.id as id2_, student0_.name as name2_, student0_.rid as rid2_, student0_.sex as sex2_ from t_student student0_ limit ?</span><br></pre></td></tr></table></figure>

<p>我们看到此时hibernate仅仅只会发出一条 sql 语句，因为第一行代码就会将整个的对象查询出来，放到session的一级缓存中去，当我如果需要再次查询学生对象时，此时首先会去缓存中看是否存在该对象，如果存在，则直接从缓存中取出，就不会再发sql了，但是要注意一点：hibernate的一级缓存是session级别的，所以如果session关闭后，缓存就没了，此时就会再次发sql去查数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">        &#123;</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line">            </span><br><span class="line">            /**</span><br><span class="line">             * 此时会发出一条sql，将所有学生全部查询出来，并放到session的一级缓存当中</span><br><span class="line">             * 当再次查询学生信息时，会首先去缓存中看是否存在，如果不存在，再去数据库中查询</span><br><span class="line">             * 这就是hibernate的一级缓存(session缓存)</span><br><span class="line">             */</span><br><span class="line">            List&lt;Student&gt; stus = (List&lt;Student&gt;)session.createQuery(&quot;from Student&quot;)</span><br><span class="line">                                    .setFirstResult(0).setMaxResults(30).list();</span><br><span class="line">            Student stu = (Student)session.load(Student.class, 1);</span><br><span class="line">            System.out.println(stu.getName() + &quot;-----------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            HibernateUtil.close(session);</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 当session关闭以后，session的一级缓存也就没有了，这时就又会去数据库中查询</span><br><span class="line">         */</span><br><span class="line">        session = HibernateUtil.openSession();</span><br><span class="line">        Student stu = (Student)session.load(Student.class, 1);</span><br><span class="line">        System.out.println(stu.getName() + &quot;-----------&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select student0_.id as id2_, student0_.name as name2_, student0_.sex as sex2_, student0_.rid as rid2_ from t_student student0_ limit ?</span><br><span class="line"></span><br><span class="line">Hibernate: select student0_.id as id2_2_, student0_.name as name2_2_, student0_.sex as sex2_2_, student0_.rid as rid2_2_, classroom1_.id as id1_0_, classroom1_.name as name1_0_, classroom1_.sid as sid1_0_, special2_.id as id0_1_, special2_.name as name0_1_, special2_.type as type0_1_ from t_student student0_ left outer join t_classroom classroom1_ on student0_.rid=classroom1_.id left outer join t_special special2_ on classroom1_.sid=special2_.id where student0_.id=?</span><br></pre></td></tr></table></figure>

<p>我们看到此时会发出两条sql语句，因为session关闭以后，一级缓存就不存在了，所以如果再查询的时候，就会再发sql。要解决这种问题，我们应该怎么做呢？这就要我们来配置hibernate的二级缓存了，也就是sessionFactory级别的缓存。</p>
<p>三、二级缓存(sessionFactory级别)</p>
<p>使用hibernate二级缓存，我们首先需要对其进行配置，配置步骤如下：</p>
<p>1.hibernate并没有提供相应的二级缓存的组件，所以需要加入额外的二级缓存包，常用的二级缓存包是EHcache。这个我们在下载好的hibernate的lib-&gt;optional-&gt;ehcache下可以找到(我这里使用的hibernate4.1.7版本)，然后将里面的几个jar包导入即可。</p>
<p>2.在hibernate.cfg.xml配置文件中配置我们二级缓存的一些属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开启二级缓存 --&gt;</span><br><span class="line">       &lt;property name=&quot;hibernate.cache.use_second_level_cache&quot;&gt;true&lt;/property&gt;</span><br><span class="line">       &lt;!-- 二级缓存的提供类 在hibernate4.0版本以后我们都是配置这个属性来指定二级缓存的提供类--&gt;</span><br><span class="line">       &lt;property name=&quot;hibernate.cache.region.factory_class&quot;&gt;org.hibernate.cache.ehcache.EhCacheRegionFactory&lt;/property&gt;</span><br><span class="line">       &lt;!-- 二级缓存配置文件的位置 --&gt;</span><br><span class="line">       &lt;property name=&quot;hibernate.cache.provider_configuration_file_resource_path&quot;&gt;ehcache.xml&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>3.配置hibernate的二级缓存是通过使用 ehcache的缓存包，所以我们需要创建一个 ehcache.xml 的配置文件，来配置我们的缓存信息，将其放到项目根目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;ehcache&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Sets the path to the directory where cache .data files are created.</span><br><span class="line"></span><br><span class="line">         If the path is a Java System Property it is replaced by</span><br><span class="line">         its value in the running VM.</span><br><span class="line"></span><br><span class="line">         The following properties are translated:</span><br><span class="line">         user.home - User&apos;s home directory</span><br><span class="line">         user.dir - User&apos;s current working directory</span><br><span class="line">         java.io.tmpdir - Default temp file path --&gt;</span><br><span class="line">　　</span><br><span class="line">　　&lt;!--指定二级缓存存放在磁盘上的位置--&gt;</span><br><span class="line">    &lt;diskStore path=&quot;user.dir&quot;/&gt;　　</span><br><span class="line"></span><br><span class="line">　　&lt;!--我们可以给每个实体类指定一个对应的缓存，如果没有匹配到该类，则使用这个默认的缓存配置--&gt;</span><br><span class="line">    &lt;defaultCache</span><br><span class="line">        maxElementsInMemory=&quot;10000&quot;　　//在内存中存放的最大对象数</span><br><span class="line">        eternal=&quot;false&quot;　　　　　　　　　//是否永久保存缓存，设置成false</span><br><span class="line">        timeToIdleSeconds=&quot;120&quot;　　　　</span><br><span class="line">        timeToLiveSeconds=&quot;120&quot;　　　　</span><br><span class="line">        overflowToDisk=&quot;true&quot;　　　　　//如果对象数量超过内存中最大的数，是否将其保存到磁盘中，设置成true</span><br><span class="line">        /&gt;</span><br><span class="line">　　</span><br><span class="line">　　&lt;!--</span><br><span class="line">　　　　1、timeToLiveSeconds的定义是：以创建时间为基准开始计算的超时时长；</span><br><span class="line">　　　　2、timeToIdleSeconds的定义是：在创建时间和最近访问时间中取出离现在最近的时间作为基准计算的超时时长；</span><br><span class="line">　　　　3、如果仅设置了timeToLiveSeconds，则该对象的超时时间=创建时间+timeToLiveSeconds，假设为A；</span><br><span class="line">　　　　4、如果没设置timeToLiveSeconds，则该对象的超时时间=max(创建时间，最近访问时间)+timeToIdleSeconds，假设为B；</span><br><span class="line">　　　　5、如果两者都设置了，则取出A、B最少的值，即min(A,B)，表示只要有一个超时成立即算超时。</span><br><span class="line">　　--&gt;</span><br><span class="line"></span><br><span class="line">　　&lt;!--可以给每个实体类指定一个配置文件，通过name属性指定，要使用类的全名--&gt;</span><br><span class="line">    &lt;cache name=&quot;com.xiaoluo.bean.Student&quot;</span><br><span class="line">        maxElementsInMemory=&quot;10000&quot;</span><br><span class="line">        eternal=&quot;false&quot;</span><br><span class="line">        timeToIdleSeconds=&quot;300&quot;</span><br><span class="line">        timeToLiveSeconds=&quot;600&quot;</span><br><span class="line">        overflowToDisk=&quot;true&quot;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;cache name=&quot;sampleCache2&quot;</span><br><span class="line">        maxElementsInMemory=&quot;1000&quot;</span><br><span class="line">        eternal=&quot;true&quot;</span><br><span class="line">        timeToIdleSeconds=&quot;0&quot;</span><br><span class="line">        timeToLiveSeconds=&quot;0&quot;</span><br><span class="line">        overflowToDisk=&quot;false&quot;</span><br><span class="line">        /&gt; --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure>

<p>4.开启我们的二级缓存</p>
<p>①如果使用xml配置，我们需要在 Student.hbm.xml 中加上一下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;hibernate-mapping package=&quot;com.xiaoluo.bean&quot;&gt;</span><br><span class="line">    &lt;class name=&quot;Student&quot; table=&quot;t_student&quot;&gt;</span><br><span class="line">        &lt;!-- 二级缓存一般设置为只读的 --&gt;</span><br><span class="line">        &lt;cache usage=&quot;read-only&quot;/&gt;</span><br><span class="line">        &lt;id name=&quot;id&quot; type=&quot;int&quot; column=&quot;id&quot;&gt;</span><br><span class="line">            &lt;generator class=&quot;native&quot;/&gt;</span><br><span class="line">        &lt;/id&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; column=&quot;name&quot; type=&quot;string&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;sex&quot; column=&quot;sex&quot; type=&quot;string&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;many-to-one name=&quot;room&quot; column=&quot;rid&quot; fetch=&quot;join&quot;&gt;&lt;/many-to-one&gt;</span><br><span class="line">    &lt;/class&gt;</span><br><span class="line">&lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure>

<p>二级缓存的使用策略一般有这几种：read-only、nonstrict-read-write、read-write、transactional。注意：我们通常使用二级缓存都是将其配置成 read-only ，即我们应当在那些不需要进行修改的实体类上使用二级缓存，否则如果对缓存进行读写的话，性能会变差，这样设置缓存就失去了意义。</p>
<p>②如果使用annotation配置，我们需要在Student这个类上加上这样一个注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name=&quot;t_student&quot;)</span><br><span class="line">@Cache(usage=CacheConcurrencyStrategy.READ_ONLY)　　//　　表示开启二级缓存，并使用read-only策略</span><br><span class="line">public class Student</span><br><span class="line">&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String sex;</span><br><span class="line">    private Classroom room;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的二级缓存配置就算完成了，接下来我们来通过测试用例测试下我们的二级缓存是否起作用</p>
<p>①二级缓存是sessionFactory级别的缓存</p>
<p>TestCase1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class TestSecondCache</span><br><span class="line">&#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testCache1()</span><br><span class="line">    &#123;</span><br><span class="line">        Session session = null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line"></span><br><span class="line">            Student stu = (Student) session.load(Student.class, 1);</span><br><span class="line">            System.out.println(stu.getName() + &quot;-----------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            HibernateUtil.close(session);</span><br><span class="line">        &#125;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 即使当session关闭以后，因为配置了二级缓存，而二级缓存是sessionFactory级别的，所以会从缓存中取出该数据</span><br><span class="line">             * 只会发出一条sql语句</span><br><span class="line">             */</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line">            Student stu = (Student) session.load(Student.class, 1);</span><br><span class="line">            System.out.println(stu.getName() + &quot;-----------&quot;);</span><br><span class="line">            /**</span><br><span class="line">             * 因为设置了二级缓存为read-only，所以不能对其进行修改</span><br><span class="line">             */</span><br><span class="line">            session.beginTransaction();</span><br><span class="line">            stu.setName(&quot;aaa&quot;);</span><br><span class="line">            session.getTransaction().commit();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            session.getTransaction().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            HibernateUtil.close(session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select student0_.id as id2_2_, student0_.name as name2_2_, student0_.sex as sex2_2_, student0_.rid as rid2_2_, classroom1_.id as id1_0_, classroom1_.name as name1_0_, classroom1_.sid as sid1_0_, special2_.id as id0_1_, special2_.name as name0_1_, special2_.type as type0_1_ from t_student student0_ left outer join t_classroom classroom1_ on student0_.rid=classroom1_.id left outer join t_special special2_ on classroom1_.sid=special2_.id where student0_.id=?</span><br><span class="line">aaa-----------</span><br><span class="line">aaa-----------</span><br></pre></td></tr></table></figure>

<p>因为二级缓存是sessionFactory级别的缓存，我们看到，在配置了二级缓存以后，当我们session关闭以后，我们再去查询对象的时候，此时hibernate首先会去二级缓存中查询是否有该对象，有就不会再发sql了。</p>
<p>②二级缓存缓存的仅仅是对象，如果查询出来的是对象的一些属性，则不会被加到缓存中去</p>
<p>TestCase2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testCache2()</span><br><span class="line">    &#123;</span><br><span class="line">        Session session = null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             * 注意：二级缓存中缓存的仅仅是对象，而下面这里只保存了姓名和性别两个字段，所以 不会被加载到二级缓存里面</span><br><span class="line">             */</span><br><span class="line">            List&lt;Object[]&gt; ls = (List&lt;Object[]&gt;) session</span><br><span class="line">                    .createQuery(&quot;select stu.name, stu.sex from Student stu&quot;)</span><br><span class="line">                    .setFirstResult(0).setMaxResults(30).list();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            HibernateUtil.close(session);</span><br><span class="line">        &#125;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 由于二级缓存缓存的是对象，所以此时会发出两条sql</span><br><span class="line">             */</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line">            Student stu = (Student) session.load(Student.class, 1);</span><br><span class="line">            System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到这个测试用例，如果我们只是取出对象的一些属性的话，则不会将其保存到二级缓存中去，因为二级缓存缓存的仅仅是对象。</p>
<p>③通过二级缓存来解决 N+1 的问题</p>
<p>TestCase3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testCache3()</span><br><span class="line">    &#123;</span><br><span class="line">        Session session = null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line">            /**</span><br><span class="line">             * 将查询出来的Student对象缓存到二级缓存中去</span><br><span class="line">             */</span><br><span class="line">            List&lt;Student&gt; stus = (List&lt;Student&gt;) session.createQuery(</span><br><span class="line">                    &quot;select stu from Student stu&quot;).list();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            HibernateUtil.close(session);</span><br><span class="line">        &#125;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 由于学生的对象已经缓存在二级缓存中了，此时再使用iterate来获取对象的时候，首先会通过一条</span><br><span class="line">             * 取id的语句，然后在获取对象时去二级缓存中，如果发现就不会再发SQL，这样也就解决了N+1问题 </span><br><span class="line">             * 而且内存占用也不多</span><br><span class="line">             */</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line">            Iterator&lt;Student&gt; iterator = session.createQuery(&quot;from Student&quot;)</span><br><span class="line">                    .iterate();</span><br><span class="line">            for (; iterator.hasNext();)</span><br><span class="line">            &#123;</span><br><span class="line">                Student stu = (Student) iterator.next();</span><br><span class="line">                System.out.println(stu.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当我们如果需要查询出两次对象的时候，可以使用二级缓存来解决N+1的问题。</p>
<p>④二级缓存会缓存 hql 语句吗？</p>
<p>TestCase4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testCache4()</span><br><span class="line">    &#123;</span><br><span class="line">        Session session = null;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line">            List&lt;Student&gt; ls = session.createQuery(&quot;from Student&quot;)</span><br><span class="line">                    .setFirstResult(0).setMaxResults(50).list();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            HibernateUtil.close(session);</span><br><span class="line">        &#125;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 使用List会发出两条一模一样的sql，此时如果希望不发sql就需要使用查询缓存</span><br><span class="line">             */</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line">            List&lt;Student&gt; ls = session.createQuery(&quot;from Student&quot;)</span><br><span class="line">                    .setFirstResult(0).setMaxResults(50).list();</span><br><span class="line">            Iterator&lt;Student&gt; stu = ls.iterator();</span><br><span class="line">            for(;stu.hasNext();)</span><br><span class="line">            &#123;</span><br><span class="line">                Student student = stu.next();</span><br><span class="line">                System.out.println(student.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            HibernateUtil.close(session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select student0_.id as id2_, student0_.name as name2_, student0_.sex as sex2_, student0_.rid as rid2_ from t_student student0_ limit ?</span><br><span class="line">Hibernate: select student0_.id as id2_, student0_.name as name2_, student0_.sex as sex2_, student0_.rid as rid2_ from t_student student0_ limit ?</span><br></pre></td></tr></table></figure>

<p>我们看到，当我们如果通过 list() 去查询两次对象时，二级缓存虽然会缓存查询出来的对象，但是我们看到发出了两条相同的查询语句，这是因为二级缓存不会缓存我们的hql查询语句，要想解决这个问题，我们就要配置我们的查询缓存了。</p>
<p>四、查询缓存(sessionFactory级别)</p>
<p>我们如果要配置查询缓存，只需要在hibernate.cfg.xml中加入一条配置即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开启查询缓存 --&gt;</span><br><span class="line">        &lt;property name=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/property&gt;</span><br></pre></td></tr></table></figure>

<p>然后我们如果在查询hql语句时要使用查询缓存，就需要在查询语句后面设置这样一个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; ls = session.createQuery(&quot;from Student where name like ?&quot;)</span><br><span class="line">                    .setCacheable(true)　　//开启查询缓存，查询缓存也是SessionFactory级别的缓存</span><br><span class="line">                    .setParameter(0, &quot;%王%&quot;)</span><br><span class="line">                    .setFirstResult(0).setMaxResults(50).list();</span><br></pre></td></tr></table></figure>

<p>如果是在annotation中，我们还需要在这个类上加上这样一个注解：@Cacheable</p>
<p>接下来我们来通过测试用例来看看我们的查询缓存</p>
<p>①查询缓存也是sessionFactory级别的缓存</p>
<p>TestCase1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        Session session = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 此时会发出一条sql取出所有的学生信息</span><br><span class="line">             */</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line">            List&lt;Student&gt; ls = session.createQuery(&quot;from Student&quot;)</span><br><span class="line">                    .setCacheable(true)  //开启查询缓存,查询缓存也是sessionFactory级别的缓存</span><br><span class="line">                    .setFirstResult(0).setMaxResults(50).list();</span><br><span class="line">            Iterator&lt;Student&gt; stus = ls.iterator();</span><br><span class="line">            for(;stus.hasNext();) &#123;</span><br><span class="line">                Student stu = stus.next();</span><br><span class="line">                System.out.println(stu.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            HibernateUtil.close(session);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 此时会发出一条sql取出所有的学生信息</span><br><span class="line">             */</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line">            List&lt;Student&gt; ls = session.createQuery(&quot;from Student&quot;)</span><br><span class="line">                    .setCacheable(true)  //开启查询缓存,查询缓存也是sessionFactory级别的缓存</span><br><span class="line">                    .setFirstResult(0).setMaxResults(50).list();</span><br><span class="line">            Iterator&lt;Student&gt; stus = ls.iterator();</span><br><span class="line">            for(;stus.hasNext();) &#123;</span><br><span class="line">                Student stu = stus.next();</span><br><span class="line">                System.out.println(stu.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            HibernateUtil.close(session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Hibernate: select student0_.id as id2_, student0_.name as name2_, student0_.sex as sex2_, student0_.rid as rid2_ from t_student student0_ limit ?</p>
<p>我们看到，此时如果我们发出两条相同的语句，hibernate也只会发出一条sql，因为已经开启了查询缓存了，并且查询缓存也是sessionFactory级别的</p>
<p>②只有当 HQL 查询语句完全相同时，连参数设置都要相同，此时查询缓存才有效</p>
<p>TestCase2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        Session session = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 此时会发出一条sql取出所有的学生信息</span><br><span class="line">             */</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line">            List&lt;Student&gt; ls = session.createQuery(&quot;from Student where name like ?&quot;)</span><br><span class="line">                    .setCacheable(true)//开启查询缓存，查询缓存也是SessionFactory级别的缓存</span><br><span class="line">                    .setParameter(0, &quot;%王%&quot;)</span><br><span class="line">                    .setFirstResult(0).setMaxResults(50).list();</span><br><span class="line">            Iterator&lt;Student&gt; stus = ls.iterator();</span><br><span class="line">            for(;stus.hasNext();) &#123;</span><br><span class="line">                Student stu = stus.next();</span><br><span class="line">                System.out.println(stu.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            HibernateUtil.close(session);</span><br><span class="line">        &#125;</span><br><span class="line">        session = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 此时会发出一条sql取出所有的学生信息</span><br><span class="line">             */</span><br><span class="line">            session = HibernateUtil.openSession();</span><br><span class="line">            /**</span><br><span class="line">             * 只有当HQL完全相同的时候，连参数都要相同，查询缓存才有效</span><br><span class="line">             */</span><br><span class="line">//            List&lt;Student&gt; ls = session.createQuery(&quot;from Student where name like ?&quot;)</span><br><span class="line">//                    .setCacheable(true)//开启查询缓存，查询缓存也是SessionFactory级别的缓存</span><br><span class="line">//                    .setParameter(0, &quot;%王%&quot;)</span><br><span class="line">//                    .setFirstResult(0).setMaxResults(50).list();</span><br><span class="line">            List&lt;Student&gt; ls = session.createQuery(&quot;from Student where name like ?&quot;)</span><br><span class="line">                    .setCacheable(true)//开启查询缓存，查询缓存也是SessionFactory级别的缓存</span><br><span class="line">                    .setParameter(0, &quot;%张%&quot;)</span><br><span class="line">                    .setFirstResult(0).setMaxResults(50).list();</span><br><span class="line">            Iterator&lt;Student&gt; stus = ls.iterator();</span><br><span class="line">            for(;stus.hasNext();) &#123;</span><br><span class="line">                Student stu = stus.next();</span><br><span class="line">                System.out.println(stu.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            HibernateUtil.close(session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: select student0_.id as id2_, student0_.name as name2_, student0_.sex as sex2_, student0_.rid as rid2_ from t_student student0_ where student0_.name like ? limit ?</span><br><span class="line"></span><br><span class="line">Hibernate: select student0_.id as id2_, student0_.name as name2_, student0_.sex as sex2_, student0_.rid as rid2_ from t_student student0_ where student0_.name like ? limit ?</span><br></pre></td></tr></table></figure>

<p>我们看到，如果我们的hql查询语句不同的话，我们的查询缓存也没有作用</p>
<p>③查询缓存也能引起 N+1 的问题</p>
<p>查询缓存也能引起 N+1 的问题，我们这里首先先将 Student 对象上的二级缓存先注释掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　&lt;!-- 二级缓存一般设置为只读的 --&gt;</span><br><span class="line">        &lt;!--　　&lt;cache usage=&quot;read-only&quot;/&gt;　　--&gt;</span><br><span class="line">```                                                     </span><br><span class="line">TestCase4：</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p> @Test<br>     public void test4() {<br>         Session session = null;<br>         try {<br>             /**<br>              * 查询缓存缓存的不是对象而是id<br>              */<br>             session = HibernateUtil.openSession();<br>             List<student> ls = session.createQuery(“from Student where name like ?”)<br>                     .setCacheable(true)//开启查询缓存，查询缓存也是SessionFactory级别的缓存<br>                     .setParameter(0, “%王%”)<br>                     .setFirstResult(0).setMaxResults(50).list();<br>             Iterator<student> stus = ls.iterator();<br>             for(;stus.hasNext();) {<br>                 Student stu = stus.next();<br>                 System.out.println(stu.getName());<br>             }<br>         } catch (Exception e) {<br>             e.printStackTrace();<br>         } finally {<br>             HibernateUtil.close(session);<br>         }</student></student></p>
<pre><code>    session = null;
    try {
        /**
         * 查询缓存缓存的是id，此时由于在缓存中已经存在了这样的一组学生数据，但是仅仅只是缓存了
         * id，所以此处会发出大量的sql语句根据id取对象，这也是发现N+1问题的第二个原因
         * 所以如果使用查询缓存必须开启二级缓存
         */
        session = HibernateUtil.openSession();
        List&lt;Student&gt; ls = session.createQuery(&quot;from Student where name like ?&quot;)
                .setCacheable(true)//开启查询缓存，查询缓存也是SessionFactory级别的缓存
                .setParameter(0, &quot;%王%&quot;)
                .setFirstResult(0).setMaxResults(50).list();
        Iterator&lt;Student&gt; stus = ls.iterator();
        for(;stus.hasNext();) {
            Student stu = stus.next();
            System.out.println(stu.getName());
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        HibernateUtil.close(session);
    }
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">Hibernate: select student0_.id as id2_, student0_.name as name2_, student0_.sex as sex2_, student0_.rid as rid2_ from t_student student0_ where student0_.name like ? limit ?</span><br><span class="line"></span><br><span class="line">Hibernate: select student0_.id as id2_2_, student0_.name as name2_2_, student0_.sex as sex2_2_, student0_.rid as rid2_2_, classroom1_.id as id1_0_, classroom1_.name as name1_0_, classroom1_.sid as sid1_0_, special2_.id as id0_1_, special2_.name as name0_1_, special2_.type as type0_1_ from t_student student0_ left outer join t_classroom classroom1_ on student0_.rid=classroom1_.id left outer join t_special special2_ on classroom1_.sid=special2_.id where student0_.id=?</span><br><span class="line">Hibernate: select student0_.id as id2_2_, student0_.name as name2_2_, student0_.sex as sex2_2_, student0_.rid as rid2_2_, classroom1_.id as id1_0_, classroom1_.name as name1_0_, classroom1_.sid as sid1_0_, special2_.id as id0_1_, special2_.name as name0_1_, special2_.type as type0_1_ from t_student student0_ left outer join t_classroom classroom1_ on student0_.rid=classroom1_.id left outer join t_special special2_ on classroom1_.sid=special2_.id where student0_.id=?</span><br><span class="line">Hibernate: select student0_.id as id2_2_, student0_.name as name2_2_, student0_.sex as sex2_2_, student0_.rid as rid2_2_, classroom1_.id as id1_0_, classroom1_.name as name1_0_, classroom1_.sid as sid1_0_, special2_.id as id0_1_, special2_.name as name0_1_, special2_.type as type0_1_ from t_student student0_ left outer join t_classroom classroom1_ on student0_.rid=classroom1_.id left outer join t_special special2_ on classroom1_.sid=special2_.id where student0_.id=?</span><br><span class="line">Hibernate: select student0_.id as id2_2_, student0_.name as name2_2_, student0_.sex as sex2_2_, student0_.rid as rid2_2_, classroom1_.id as id1_0_, classroom1_.name as name1_0_, classroom1_.sid as sid1_0_, special2_.id as id0_1_, special2_.name as name0_1_, special2_.type as type0_1_ from t_student student0_ left outer join t_classroom classroom1_ on student0_.rid=classroom1_.id left outer join t_special special2_ on classroom1_.sid=special2_.id where student0_.id=?</span><br><span class="line"></span><br><span class="line">.........................</span><br></pre></td></tr></table></figure>

<p>我们看到，当我们将二级缓存注释掉以后，在使用查询缓存时，也会出现 N+1 的问题，为什么呢？</p>
<p>因为查询缓存缓存的也仅仅是对象的id，所以第一条 sql 也是将对象的id都查询出来，但是当我们后面如果要得到每个对象的信息的时候，此时又会发sql语句去查询，所以，如果要使用查询缓存，我们一定也要开启我们的二级缓存，这样就不会出现 N+1 问题了           </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/02/hibernate-session/" data-id="cjydsg9hm000vz0nw043zuj80" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/11/引用/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          引用
        
      </div>
    </a>
  
  
    <a href="/2019/02/27/mysql/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">mysql</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现/">悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量-重量级锁、读写锁、各种锁及其Java实现/" style="font-size: 10px;">悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/22/跳表/">跳表</a>
          </li>
        
          <li>
            <a href="/2019/07/18/integer/">integer</a>
          </li>
        
          <li>
            <a href="/2019/07/16/lock/">lock</a>
          </li>
        
          <li>
            <a href="/2019/07/16/lock_20190718_210149/">lock</a>
          </li>
        
          <li>
            <a href="/2019/06/22/redis-cluster/">redis-cluster</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>